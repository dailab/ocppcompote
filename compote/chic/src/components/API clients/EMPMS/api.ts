/* tslint:disable */
/* eslint-disable */
/**
 * EMPMS API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 * Specifies how the charging station can be accessed.  | Option | Description | | ------ | ----------- | | Free publicly accessible | EV Driver can reach the charging point without paying a fee, e.g. street, free public place, free parking lot, etc. | | Restricted access | EV Driver needs permission to reach the charging point, e.g. Campus, building complex, etc. | | Paying publicly accessible | EV Driver needs to pay a fee in order to reach the charging point, e.g. payable parking garage, etc. | | Test Station | Station is just for testing purposes. Access may be restricted. |
 * @export
 * @enum {string}
 */

export const Accessibility = {
  FreePubliclyAccessible: "Free publicly accessible",
  RestrictedAccess: "Restricted access",
  PayingPubliclyAccessible: "Paying publicly accessible",
  TestStation: "Test Station",
} as const;

export type Accessibility = (typeof Accessibility)[keyof typeof Accessibility];

/**
 * AddressIso19773
 * @export
 * @interface AddressIso19773
 */
export interface AddressIso19773 {
  /**
   * The CountryCodeType allows for Alpha-3 country codes only as of OICP 2.2 and OICP 2.3  For Alpha-3 (three-letter) country codes as defined in ISO 3166-1.  __Examples:__  | Option | Description | | ------ | ----------- | | AUT | Austria | | DEU | Germany | | FRA | France | | USA | United States |
   * @type {string}
   * @memberof AddressIso19773
   */
  Country: string;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  City: string;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  Street: string;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  PostalCode: string;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  HouseNum: string;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  Floor?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  Region?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof AddressIso19773
   */
  ParkingFacility?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  ParkingSpot?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressIso19773
   */
  TimeZone?: string | null;
}
/**
 * | Option | Description | | NFC RFID Classic | Defined authentication. | | NFC RFID DESFire | Defined authentication. | | PnC | ISO/IEC 15118. | | REMOTE | App, QR-Code, Phone. | | Direct Payment | Remote use via direct payment. E.g. intercharge direct | | No Authentication Required | Not Authentication Method Required |
 * @export
 * @enum {string}
 */

export const AuthenticationMode = {
  NfcRfidClassic: "NFC RFID Classic",
  NfcRfidDesFire: "NFC RFID DESFire",
  PnC: "PnC",
  Remote: "REMOTE",
  DirectPayment: "Direct Payment",
  NoAuthenticationRequired: "No Authentication Required",
} as const;

export type AuthenticationMode =
  (typeof AuthenticationMode)[keyof typeof AuthenticationMode];

/**
 *
 * @export
 * @interface Body
 */
export interface Body {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof Body
   */
  ProviderID: string;
  /**
   *
   * @type {ERoamingPullEVSEStatusSearchCenterInput}
   * @memberof Body
   */
  SearchCenter?: ERoamingPullEVSEStatusSearchCenterInput;
  /**
   *
   * @type {EvseStatus}
   * @memberof Body
   */
  EVSEStatus?: EvseStatus;
  /**
   *
   * @type {Array<string>}
   * @memberof Body
   */
  EvseID: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Body
   */
  OperatorID: Array<string>;
}

/**
 *
 * @export
 * @interface Body1
 */
export interface Body1 {
  /**
   *
   * @type {ChargingNotificationType}
   * @memberof Body1
   */
  Type: ChargingNotificationType;
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof Body1
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  CPOPartnerSessionID?: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  EMPPartnerSessionID?: string;
  /**
   *
   * @type {IdentificationInput}
   * @memberof Body1
   */
  Identification?: IdentificationInput;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof Body1
   */
  EvseID: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  ChargingStart: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  SessionStart?: string;
  /**
   *
   * @type {Metervaluestart}
   * @memberof Body1
   */
  MeterValueStart?: Metervaluestart | null;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof Body1
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  PartnerProductID?: string;
  /**
   * The date and time at which the charging progress parameters are captured.
   * @type {string}
   * @memberof Body1
   */
  EventOccurred: string;
  /**
   *
   * @type {number}
   * @memberof Body1
   */
  ChargingDuration?: number;
  /**
   *
   * @type {Consumedenergyprogress}
   * @memberof Body1
   */
  ConsumedEnergyProgress?: Consumedenergyprogress | null;
  /**
   *
   * @type {ERoamingChargeDetailRecordMeterValueInBetween}
   * @memberof Body1
   */
  MeterValueInBetween?: ERoamingChargeDetailRecordMeterValueInBetween;
  /**
   * The date and time at which the charging process stoped.
   * @type {string}
   * @memberof Body1
   */
  ChargingEnd: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  SessionEnd?: string;
  /**
   *
   * @type {Consumedenergy1}
   * @memberof Body1
   */
  ConsumedEnergy?: Consumedenergy1 | null;
  /**
   *
   * @type {Metervalueend}
   * @memberof Body1
   */
  MeterValueEnd?: Metervalueend | null;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  PenaltyTimeStart?: string;
  /**
   * | Option | Description | | ------ | ----------- | | ConnectorError | Charging process cannot be started or stopped. EV driver needs to check if the the Plug is properly inserted or taken out from socket. | | CriticalError | Charging process stopped abruptly. Reason: Physical check at the station is required. Station cannot be reset online. <br /> Or <br /> Error with the software or hardware of the station locally. <br /> Or <br /> Communication failure with the vehicle. <br /> Or <br /> The error needs to be investigated <br /> Or <br /> Ground Failure |
   * @type {string}
   * @memberof Body1
   */
  ErrorType: string;
  /**
   *
   * @type {string}
   * @memberof Body1
   */
  ErrorAdditionalInfo?: string;
}

/**
 * ChargingFacility
 * @export
 * @interface ChargingFacility
 */
export interface ChargingFacility {
  /**
   * Charging Facility power type (e.g. AC or DC)
   * @type {string}
   * @memberof ChargingFacility
   */
  PowerType: string;
  /**
   *
   * @type {number}
   * @memberof ChargingFacility
   */
  Voltage?: number | null;
  /**
   *
   * @type {number}
   * @memberof ChargingFacility
   */
  Amperage?: number | null;
  /**
   * Charging Facility power in kW
   * @type {number}
   * @memberof ChargingFacility
   */
  Power: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ChargingFacility
   */
  ChargingModes?: Array<string> | null;
}
/**
 * The type of ChargingNotification
 * @export
 * @enum {string}
 */

export const ChargingNotificationType = {
  Start: "Start",
  Progress: "Progress",
  End: "End",
  Error: "Error",
} as const;

export type ChargingNotificationType =
  (typeof ChargingNotificationType)[keyof typeof ChargingNotificationType];

/**
 * Total CO2 emited by the energy source being used by this charging station to supply energy to EV. Units are in g/kWh
 * @export
 * @interface Co2Emission
 */
export interface Co2Emission {}
/**
 * The difference between MeterValueEnd and MeterValueStart in kWh.
 * @export
 * @interface Consumedenergy
 */
export interface Consumedenergy {}
/**
 * The difference between MeterValueEnd and MeterValueStart in kWh.
 * @export
 * @interface Consumedenergy1
 */
export interface Consumedenergy1 {}
/**
 * This is consumed energy when from Start of charging process till the charging progress notification generated (EventOccurred)  Either ChargingDuration or ConsumedEnergyProgress should be provided. Both can also be provided with each progress notification.
 * @export
 * @interface Consumedenergyprogress
 */
export interface Consumedenergyprogress {}
/**
 * The acknowledgement is a message that is sent in response to several requests.  * To `SEND` and `RECEIVE` * Implementation: `MANDATORY`
 * @export
 * @interface ERoamingAcknowledgment
 */
export interface ERoamingAcknowledgment {
  /**
   * If result is true, the message was received and the respective operation was performed successfully.  If result is false, the message was received and the respective operation was not performed successfully.
   * @type {boolean}
   * @memberof ERoamingAcknowledgment
   */
  Result: boolean;
  /**
   *
   * @type {StatusCode}
   * @memberof ERoamingAcknowledgment
   */
  StatusCode: StatusCode;
  /**
   *
   * @type {string}
   * @memberof ERoamingAcknowledgment
   */
  SessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAcknowledgment
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAcknowledgment
   */
  EMPPartnerSessionID?: string | null;
}
/**
 * Note:   * To `RECEIVE`   * Implementation: `MANDATORY`  eRoamingAuthorizationStart is a message that authorizes a user to charge a car. NOTE: This message describes the response which has to be receive in response to the eRoamingAuthorizeStart.
 * @export
 * @interface ERoamingAuthorizationStart
 */
export interface ERoamingAuthorizationStart {
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStart
   */
  SessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStart
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStart
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStart
   */
  ProviderID?: string | null;
  /**
   * Information specifying whether the user is authorized to charge or not.  | Option | Description | | ------ | ----------- | | Authorized | User is authorized | | NotAuthorized | User is not authorized |
   * @type {string}
   * @memberof ERoamingAuthorizationStart
   */
  AuthorizationStatus: string;
  /**
   *
   * @type {StatusCode}
   * @memberof ERoamingAuthorizationStart
   */
  StatusCode: StatusCode;
  /**
   *
   * @type {Array<ERoamingAuthorizationStartAuthorizationStopIdentificationsInner>}
   * @memberof ERoamingAuthorizationStart
   */
  AuthorizationStopIdentifications?: Array<ERoamingAuthorizationStartAuthorizationStopIdentificationsInner> | null;
}
/**
 * ERoamingAuthorizationStartAuthorizationStopIdentificationsInner
 * @export
 * @interface ERoamingAuthorizationStartAuthorizationStopIdentificationsInner
 */
export interface ERoamingAuthorizationStartAuthorizationStopIdentificationsInner {
  /**
   *
   * @type {RFIDMifareFamilyIdentification}
   * @memberof ERoamingAuthorizationStartAuthorizationStopIdentificationsInner
   */
  RFIDMifareFamilyIdentification?: RFIDMifareFamilyIdentification | null;
  /**
   *
   * @type {RFIDIdentification}
   * @memberof ERoamingAuthorizationStartAuthorizationStopIdentificationsInner
   */
  RFIDIdentification?: RFIDIdentification | null;
  /**
   *
   * @type {QRCodeIdentificationOutput}
   * @memberof ERoamingAuthorizationStartAuthorizationStopIdentificationsInner
   */
  QRCodeIdentification?: QRCodeIdentificationOutput | null;
  /**
   *
   * @type {PlugAndChargeIdentification}
   * @memberof ERoamingAuthorizationStartAuthorizationStopIdentificationsInner
   */
  PlugAndChargeIdentification?: PlugAndChargeIdentification | null;
  /**
   *
   * @type {RemoteIdentification}
   * @memberof ERoamingAuthorizationStartAuthorizationStopIdentificationsInner
   */
  RemoteIdentification?: RemoteIdentification | null;
}
/**
 * Note:   * To `RECEIVE`   * Implementation: `OPTIONAL`  eRoamingAuthorizeStop is a message to request an authorization for stopping a charging process.  Note:  This message describes the response which has to be received in return to the eRoamingAuthorizeStop request.
 * @export
 * @interface ERoamingAuthorizationStop
 */
export interface ERoamingAuthorizationStop {
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStop
   */
  SessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStop
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStop
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizationStop
   */
  ProviderID?: string | null;
  /**
   * Information specifying whether the user is authorized to charge or not.  | Option | Description | | ------ | ----------- | | Authorized | User is authorized | | NotAuthorized | User is not authorized |
   * @type {string}
   * @memberof ERoamingAuthorizationStop
   */
  AuthorizationStatus: string;
  /**
   *
   * @type {StatusCode}
   * @memberof ERoamingAuthorizationStop
   */
  StatusCode: StatusCode;
}
/**
 * ERoamingAuthorizeRemoteReservationStart
 * @export
 * @interface ERoamingAuthorizeRemoteReservationStart
 */
export interface ERoamingAuthorizeRemoteReservationStart {
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  SessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  EMPPartnerSessionId?: string | null;
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  ProviderID: string;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  EvseID: string;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  Identification: IdentificationInput;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  PartnerProductID?: string | null;
  /**
   *
   * @type {number}
   * @memberof ERoamingAuthorizeRemoteReservationStart
   */
  Duration?: number | null;
}
/**
 * ERoamingAuthorizeRemoteReservationStop
 * @export
 * @interface ERoamingAuthorizeRemoteReservationStop
 */
export interface ERoamingAuthorizeRemoteReservationStop {
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStop
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStop
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStop
   */
  EMPPartnerSessionId?: string | null;
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStop
   */
  ProviderID: string;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteReservationStop
   */
  EvseID: string;
}
/**
 * ERoamingAuthorizeRemoteStart
 * @export
 * @interface ERoamingAuthorizeRemoteStart
 */
export interface ERoamingAuthorizeRemoteStart {
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStart
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStart
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStart
   */
  EMPPartnerSessionID?: string | null;
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStart
   */
  ProviderID: string;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStart
   */
  EvseID: string;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingAuthorizeRemoteStart
   */
  Identification: IdentificationInput;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStart
   */
  PartnerProductID?: string | null;
}
/**
 * ERoamingAuthorizeRemoteStop
 * @export
 * @interface ERoamingAuthorizeRemoteStop
 */
export interface ERoamingAuthorizeRemoteStop {
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStop
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStop
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStop
   */
  EMPPartnerSessionID?: string | null;
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStop
   */
  ProviderID: string;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingAuthorizeRemoteStop
   */
  EvseID: string;
}
/**
 * Best Practices: * The EVSE ID is optional for this message which is e.g. defined after the RFID authorization at a charge point. If the Evse ID can be provided, we recommend to include the EVSE ID in this message; it will help for support matters. * If an authorization process could not successfully be executed, please set an error code by refering to the error code list mentioned in the OICP document.
 * @export
 * @interface ERoamingAuthorizeStart
 */
export interface ERoamingAuthorizeStart {
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStart
   */
  SessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStart
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStart
   */
  EMPPartnerSessionID?: string | null;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingAuthorizeStart
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStart
   */
  EvseID?: string | null;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingAuthorizeStart
   */
  Identification: IdentificationInput;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStart
   */
  PartnerProductID?: string | null;
}
/**
 * ERoamingAuthorizeStop
 * @export
 * @interface ERoamingAuthorizeStop
 */
export interface ERoamingAuthorizeStop {
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingAuthorizeStop
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStop
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStop
   */
  EMPPartnerSessionID?: string | null;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingAuthorizeStop
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingAuthorizeStop
   */
  EvseID?: string | null;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingAuthorizeStop
   */
  Identification: IdentificationInput;
}
/**
 * This field provides additional information which could help directly or indirectly to verify the signed metering value by using respective Transparency Software
 * @export
 * @interface ERoamingChargeDetailRecordCalibrationLawVerificationInfo
 */
export interface ERoamingChargeDetailRecordCalibrationLawVerificationInfo {
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordCalibrationLawVerificationInfo
   */
  CalibrationLawCertificateID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordCalibrationLawVerificationInfo
   */
  PublicKey?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordCalibrationLawVerificationInfo
   */
  MeteringSignatureUrl?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordCalibrationLawVerificationInfo
   */
  MeteringSignatureEncodingFormat?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordCalibrationLawVerificationInfo
   */
  SignedMeteringValuesVerificationInstruction?: string | null;
}
/**
 * eRoamingChargeDetailRecord is a message that contains charging process details (e.g. meter values).
 * @export
 * @interface ERoamingChargeDetailRecordInput
 */
export interface ERoamingChargeDetailRecordInput {
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  PartnerProductID?: string | null;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  EvseID: string;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingChargeDetailRecordInput
   */
  Identification: IdentificationInput;
  /**
   * The date and time at which the charging process started.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  ChargingStart: string;
  /**
   * The date and time at which the charging process stoped.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  ChargingEnd: string;
  /**
   * The date and time at which the session started, e.g. swipe of RFID or cable connected.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  SessionStart: string;
  /**
   * The date and time at which the session started, e.g. swipe of RFID or cable connected.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  SessionEnd: string;
  /**
   *
   * @type {Metervaluestart}
   * @memberof ERoamingChargeDetailRecordInput
   */
  MeterValueStart?: Metervaluestart | null;
  /**
   *
   * @type {Metervalueend}
   * @memberof ERoamingChargeDetailRecordInput
   */
  MeterValueEnd?: Metervalueend | null;
  /**
   *
   * @type {ERoamingChargeDetailRecordMeterValueInBetween}
   * @memberof ERoamingChargeDetailRecordInput
   */
  MeterValueInBetween?: ERoamingChargeDetailRecordMeterValueInBetween | null;
  /**
   *
   * @type {Consumedenergy}
   * @memberof ERoamingChargeDetailRecordInput
   */
  ConsumedEnergy: Consumedenergy;
  /**
   *
   * @type {Array<ERoamingChargeDetailRecordSignedMeteringValuesInner>}
   * @memberof ERoamingChargeDetailRecordInput
   */
  SignedMeteringValues?: Array<ERoamingChargeDetailRecordSignedMeteringValuesInner> | null;
  /**
   *
   * @type {ERoamingChargeDetailRecordCalibrationLawVerificationInfo}
   * @memberof ERoamingChargeDetailRecordInput
   */
  CalibrationLawVerificationInfo?: ERoamingChargeDetailRecordCalibrationLawVerificationInfo | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  HubOperatorID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordInput
   */
  HubProviderId?: string | null;
}
/**
 * List of meter values that may have been taken in between (kWh).
 * @export
 * @interface ERoamingChargeDetailRecordMeterValueInBetween
 */
export interface ERoamingChargeDetailRecordMeterValueInBetween {
  /**
   *
   * @type {Array<ERoamingChargeDetailRecordMeterValueInBetweenMeterValuesInner>}
   * @memberof ERoamingChargeDetailRecordMeterValueInBetween
   */
  meterValues?: Array<ERoamingChargeDetailRecordMeterValueInBetweenMeterValuesInner> | null;
}
/**
 *
 * @export
 * @interface ERoamingChargeDetailRecordMeterValueInBetweenMeterValuesInner
 */
export interface ERoamingChargeDetailRecordMeterValueInBetweenMeterValuesInner {}
/**
 * eRoamingChargeDetailRecord is a message that contains charging process details (e.g. meter values).
 * @export
 * @interface ERoamingChargeDetailRecordOutput
 */
export interface ERoamingChargeDetailRecordOutput {
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  PartnerProductID?: string | null;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  EvseID: string;
  /**
   *
   * @type {IdentificationOutput}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  Identification: IdentificationOutput;
  /**
   * The date and time at which the charging process started.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  ChargingStart: string;
  /**
   * The date and time at which the charging process stoped.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  ChargingEnd: string;
  /**
   * The date and time at which the session started, e.g. swipe of RFID or cable connected.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  SessionStart: string;
  /**
   * The date and time at which the session started, e.g. swipe of RFID or cable connected.
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  SessionEnd: string;
  /**
   *
   * @type {Metervaluestart}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  MeterValueStart?: Metervaluestart | null;
  /**
   *
   * @type {Metervalueend}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  MeterValueEnd?: Metervalueend | null;
  /**
   *
   * @type {ERoamingChargeDetailRecordMeterValueInBetween}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  MeterValueInBetween?: ERoamingChargeDetailRecordMeterValueInBetween | null;
  /**
   *
   * @type {Consumedenergy}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  ConsumedEnergy: Consumedenergy;
  /**
   *
   * @type {Array<ERoamingChargeDetailRecordSignedMeteringValuesInner>}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  SignedMeteringValues?: Array<ERoamingChargeDetailRecordSignedMeteringValuesInner> | null;
  /**
   *
   * @type {ERoamingChargeDetailRecordCalibrationLawVerificationInfo}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  CalibrationLawVerificationInfo?: ERoamingChargeDetailRecordCalibrationLawVerificationInfo | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  HubOperatorID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordOutput
   */
  HubProviderId?: string | null;
}
/**
 * ERoamingChargeDetailRecordSignedMeteringValuesInner
 * @export
 * @interface ERoamingChargeDetailRecordSignedMeteringValuesInner
 */
export interface ERoamingChargeDetailRecordSignedMeteringValuesInner {
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordSignedMeteringValuesInner
   */
  SignedMeteringValue?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargeDetailRecordSignedMeteringValuesInner
   */
  MeteringStatus?: string | null;
}
/**
 * eRoamingChargeDetailRecord is a message containing charging process details (such as meter values, etc.).
 * @export
 * @interface ERoamingChargeDetailRecords
 */
export interface ERoamingChargeDetailRecords {
  /**
   *
   * @type {Array<ERoamingChargeDetailRecordOutput>}
   * @memberof ERoamingChargeDetailRecords
   */
  content: Array<ERoamingChargeDetailRecordOutput>;
  /**
   * Number of the page
   * @type {number}
   * @memberof ERoamingChargeDetailRecords
   */
  number: number;
  /**
   * Size of records requested per page
   * @type {number}
   * @memberof ERoamingChargeDetailRecords
   */
  size: number;
  /**
   * Number of total charge detail records available from the request
   * @type {number}
   * @memberof ERoamingChargeDetailRecords
   */
  totalElements: number;
  /**
   * Indicates if the current page is the last page
   * @type {boolean}
   * @memberof ERoamingChargeDetailRecords
   */
  last: boolean;
  /**
   * Number of total pages available for the request
   * @type {number}
   * @memberof ERoamingChargeDetailRecords
   */
  totalPages: number;
  /**
   * indicates if the current page is the first page
   * @type {boolean}
   * @memberof ERoamingChargeDetailRecords
   */
  first: boolean;
  /**
   * Number of records in the page
   * @type {number}
   * @memberof ERoamingChargeDetailRecords
   */
  numberOfElements: number;
  /**
   *
   * @type {StatusCode}
   * @memberof ERoamingChargeDetailRecords
   */
  StatusCode: StatusCode;
}
/**
 * A customer of an EMP has fully charged a vehicle at a charging station of a CPO. The charging process was started with an eRoamingAuthorizeStart or an eRoamingAuthorizeRemoteStart operation. The energy flow has ended, but the process has not yet been stopped and the vehicle is blocking the charging station.  The CPO’s backend system MAY send a ChargingNotification of type “End” after the CPO considers the charging of an EV concluded (because no energy is transmitted anymore) in order to inform the EMP that the actual charging (the energy flow) of the vehicle has stopped. The charging process has not yet been stopped by the customer and the session is still active.  The ChargingNotification of type “End” is a message that contains information about the charging end of a session (e.g. ConsumedEnergy, ChargingEnd).
 * @export
 * @interface ERoamingChargingNotificationEnd
 */
export interface ERoamingChargingNotificationEnd {
  /**
   *
   * @type {ChargingNotificationType}
   * @memberof ERoamingChargingNotificationEnd
   */
  Type: ChargingNotificationType;
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingChargingNotificationEnd
   */
  Identification?: IdentificationInput | null;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  EvseID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  ChargingStart?: string | null;
  /**
   * The date and time at which the charging process stoped.
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  ChargingEnd: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  SessionStart?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  SessionEnd?: string | null;
  /**
   *
   * @type {Consumedenergy1}
   * @memberof ERoamingChargingNotificationEnd
   */
  ConsumedEnergy?: Consumedenergy1 | null;
  /**
   *
   * @type {Metervaluestart}
   * @memberof ERoamingChargingNotificationEnd
   */
  MeterValueStart?: Metervaluestart | null;
  /**
   *
   * @type {Metervalueend}
   * @memberof ERoamingChargingNotificationEnd
   */
  MeterValueEnd?: Metervalueend | null;
  /**
   *
   * @type {ERoamingChargeDetailRecordMeterValueInBetween}
   * @memberof ERoamingChargingNotificationEnd
   */
  MeterValueInBetween?: ERoamingChargeDetailRecordMeterValueInBetween | null;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  PartnerProductID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationEnd
   */
  PenaltyTimeStart?: string | null;
}

/**
 * A customer of EMP Authorizes the charging session at particular charging station (via any means for eg REFID card, Mobile etc). Due to some errors sometime, it is possible that charging does not start or charging process is abruptly stopped or fluctuations in the charging process. It is really important for Customer as well as EMP to know what exactly is happening at the charging process. This notification eventually helps EMPs well informed about the problem occurred with the charging process. This information can be easily passed onto Customer so that he/she can take appropriate action.  The CPO’s backend system MAY send a ChargingNotification of type “Error” after the CPO gets an information about the error at the charging station. The CPO can transmit one of the ErrorClass defined by Hubject along with the additional information which elaborated the Error. The customer has to take one of the three action EV needs to be charged at some different station, Cables is properly attached or the error is for information only no action required by customer.  The ChargingNotification of type “Error” is a message that contains information about the charging end of a session (e.g. ErrorClass, ErrorAdditionalInfo).
 * @export
 * @interface ERoamingChargingNotificationError
 */
export interface ERoamingChargingNotificationError {
  /**
   *
   * @type {ChargingNotificationType}
   * @memberof ERoamingChargingNotificationError
   */
  Type: ChargingNotificationType;
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingChargingNotificationError
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationError
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationError
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingChargingNotificationError
   */
  Identification?: IdentificationInput | null;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingChargingNotificationError
   */
  OperatorID: string;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingChargingNotificationError
   */
  EvseID: string;
  /**
   * | Option | Description | | ------ | ----------- | | ConnectorError | Charging process cannot be started or stopped. EV driver needs to check if the the Plug is properly inserted or taken out from socket. | | CriticalError | Charging process stopped abruptly. Reason: Physical check at the station is required. Station cannot be reset online. <br /> Or <br /> Error with the software or hardware of the station locally. <br /> Or <br /> Communication failure with the vehicle. <br /> Or <br /> The error needs to be investigated <br /> Or <br /> Ground Failure |
   * @type {string}
   * @memberof ERoamingChargingNotificationError
   */
  ErrorType: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationError
   */
  ErrorAdditionalInfo?: string | null;
}

/**
 * A customer of EMP has started the charging session. Just like as that of regular gasoline stations customer would like to know either how much charging Duration have passed or how much energy is consumed by the EV so far. This information will help Customer to decide if he/she wants to stop the charging session as per their affordability or journey planning.  The CPO’s backend system MAY send a ChargingNotification of type “Progess” after the CPO gets the charging energy or time information from EVSEID. This is required in order to inform the EMP that the progress energy or chargingduration for a perticular charging session.  The ChargingNotification of type “Progress” is a message that contains information about the charging Duration or energy consumed during charging process (e.g. EventOccurred, ChargingDuration, ConsumedEnergyProgress).
 * @export
 * @interface ERoamingChargingNotificationProgress
 */
export interface ERoamingChargingNotificationProgress {
  /**
   *
   * @type {ChargingNotificationType}
   * @memberof ERoamingChargingNotificationProgress
   */
  Type: ChargingNotificationType;
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingChargingNotificationProgress
   */
  Identification?: IdentificationInput | null;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  EvseID: string;
  /**
   * The date and time at which the charging process started.
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  ChargingStart: string;
  /**
   * The date and time at which the charging progress parameters are captured.
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  EventOccurred: string;
  /**
   *
   * @type {number}
   * @memberof ERoamingChargingNotificationProgress
   */
  ChargingDuration?: number | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  SessionStart?: string | null;
  /**
   *
   * @type {Consumedenergyprogress}
   * @memberof ERoamingChargingNotificationProgress
   */
  ConsumedEnergyProgress?: Consumedenergyprogress | null;
  /**
   *
   * @type {Metervaluestart}
   * @memberof ERoamingChargingNotificationProgress
   */
  MeterValueStart?: Metervaluestart | null;
  /**
   *
   * @type {ERoamingChargeDetailRecordMeterValueInBetween}
   * @memberof ERoamingChargingNotificationProgress
   */
  MeterValueInBetween?: ERoamingChargeDetailRecordMeterValueInBetween | null;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationProgress
   */
  PartnerProductID?: string | null;
}

/**
 * A customer of EMP Authorizes the charging session at particular charging station (via any means for eg REFID card, Mobile etc). The charging session is authorized by Hubject / CPO system. The authorization of charging process and plugging the cable in EV does not guarantee that energy flow into the Vehicle is initiated. It is really important for for EMP and its end consumer to know if the charging has started.  The CPO’s backend system MAY send a ChargingNotification of type “Start” after the CPO considers the charging of an EV is started (since energy flow have started) in order to inform the EMP that the actual charging (the energy flow) of the vehicle has started.  The ChargingNotification of type “Start” is a message that contains information about the charging start of a session (e.g. ChargingStart).
 * @export
 * @interface ERoamingChargingNotificationStart
 */
export interface ERoamingChargingNotificationStart {
  /**
   *
   * @type {ChargingNotificationType}
   * @memberof ERoamingChargingNotificationStart
   */
  Type: ChargingNotificationType;
  /**
   * The Hubject SessionID that identifies the process  A string that `MUST` be valid with respect to the following regular expression:  `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`  The expression validates the string as a GUID.  Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  SessionID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  CPOPartnerSessionID?: string | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  EMPPartnerSessionID?: string | null;
  /**
   *
   * @type {IdentificationInput}
   * @memberof ERoamingChargingNotificationStart
   */
  Identification?: IdentificationInput | null;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  EvseID: string;
  /**
   * The date and time at which the charging process started.
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  ChargingStart: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  SessionStart?: string | null;
  /**
   *
   * @type {Metervaluestart}
   * @memberof ERoamingChargingNotificationStart
   */
  MeterValueStart?: Metervaluestart | null;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingChargingNotificationStart
   */
  PartnerProductID?: string | null;
}

/**
 * ERoamingEVSEData
 * @export
 * @interface ERoamingEVSEData
 */
export interface ERoamingEVSEData {
  /**
   * A list of EVSE data blocks that are each assigned to a certain operator.
   * @type {Array<PullEvseDataRecord>}
   * @memberof ERoamingEVSEData
   */
  content: Array<PullEvseDataRecord>;
  /**
   * Number of the page
   * @type {number}
   * @memberof ERoamingEVSEData
   */
  number: number;
  /**
   * Size of records requested per page
   * @type {number}
   * @memberof ERoamingEVSEData
   */
  size: number;
  /**
   * Number of total charging stations available from the request
   * @type {number}
   * @memberof ERoamingEVSEData
   */
  totalElements: number;
  /**
   * Indicates if the current page is the last page
   * @type {boolean}
   * @memberof ERoamingEVSEData
   */
  last: boolean;
  /**
   * Number of total pages available for the request
   * @type {number}
   * @memberof ERoamingEVSEData
   */
  totalPages: number;
  /**
   * indicates if the current page is the first page
   * @type {boolean}
   * @memberof ERoamingEVSEData
   */
  first: boolean;
  /**
   * Number of records in the page
   * @type {number}
   * @memberof ERoamingEVSEData
   */
  numberOfElements: number;
  /**
   *
   * @type {StatusCode}
   * @memberof ERoamingEVSEData
   */
  StatusCode: StatusCode;
}
/**
 * eRoamingEVSEPricing is sent by the HBS in response to eRoamingPullEVSEPricing requests.  Note:   * This message describes the response which has to be sent in reply to the eRoamingPullEVSEPricing request.
 * @export
 * @interface ERoamingEVSEPricing
 */
export interface ERoamingEVSEPricing {
  /**
   * A list of EVSE pricing data blocks for specific operators
   * @type {Array<ERoamingEVSEPricingEVSEPricingInner>}
   * @memberof ERoamingEVSEPricing
   */
  EVSEPricing: Array<ERoamingEVSEPricingEVSEPricingInner>;
  /**
   *
   * @type {StatusCode}
   * @memberof ERoamingEVSEPricing
   */
  StatusCode?: StatusCode | null;
}
/**
 * ERoamingEVSEPricingEVSEPricingInner
 * @export
 * @interface ERoamingEVSEPricingEVSEPricingInner
 */
export interface ERoamingEVSEPricingEVSEPricingInner {
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingEVSEPricingEVSEPricingInner
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingEVSEPricingEVSEPricingInner
   */
  OperatorName?: string | null;
  /**
   * List of EVSE pricings offered by the operator.
   * @type {Array<ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner>}
   * @memberof ERoamingEVSEPricingEVSEPricingInner
   */
  EVSEPricing: Array<ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner>;
}
/**
 * ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner
 * @export
 * @interface ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner
 */
export interface ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner {
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner
   */
  EvseID: string;
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner
   */
  ProviderID: string;
  /**
   * A list of pricing products applicable per EvseID
   * @type {Array<string>}
   * @memberof ERoamingEVSEPricingEVSEPricingInnerEVSEPricingInner
   */
  EvseIDProductList: Array<string>;
}
/**
 * eRoamingGetChargeDetailRecords is a message to request a list of charge detail records.  Important: * This message is only mandatory for offline EMPs.
 * @export
 * @interface ERoamingGetChargeDetailRecords
 */
export interface ERoamingGetChargeDetailRecords {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingGetChargeDetailRecords
   */
  ProviderID: string;
  /**
   * Start of the requested time range.
   * @type {string}
   * @memberof ERoamingGetChargeDetailRecords
   */
  From: string;
  /**
   * End of the requested time range.
   * @type {string}
   * @memberof ERoamingGetChargeDetailRecords
   */
  To: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ERoamingGetChargeDetailRecords
   */
  SessionID?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingGetChargeDetailRecords
   */
  OperatorID?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof ERoamingGetChargeDetailRecords
   */
  CDRForwarder?: boolean | null;
}
/**
 * eRoamingPricingProductData is sent in response to eRoamingPullPricingProductData requests.  Note:   * This message describes the response which has to be sent in reply to the eRoamingPullPricingProductData request.
 * @export
 * @interface ERoamingPricingProductData
 */
export interface ERoamingPricingProductData {
  /**
   * List of pricing products offered by operators for a specific provider
   * @type {Array<ERoamingPricingProductDataPricingProductDataInner>}
   * @memberof ERoamingPricingProductData
   */
  PricingProductData: Array<ERoamingPricingProductDataPricingProductDataInner>;
  /**
   *
   * @type {StatusCode}
   * @memberof ERoamingPricingProductData
   */
  StatusCode?: StatusCode | null;
}
/**
 * ERoamingPricingProductDataPricingProductDataInner
 * @export
 * @interface ERoamingPricingProductDataPricingProductDataInner
 */
export interface ERoamingPricingProductDataPricingProductDataInner {
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof ERoamingPricingProductDataPricingProductDataInner
   */
  OperatorID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingPricingProductDataPricingProductDataInner
   */
  OperatorName?: string | null;
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”   In case the data is to be made available for all EMPs (e.g. for Offer-to-All prices), the asterix character (*) can be set as the value in this field.
   * @type {string}
   * @memberof ERoamingPricingProductDataPricingProductDataInner
   */
  ProviderID: string;
  /**
   *
   * @type {Pricingdefaultprice}
   * @memberof ERoamingPricingProductDataPricingProductDataInner
   */
  PricingDefaultPrice: Pricingdefaultprice;
  /**
   * The ProductPriceCurrencyType allows for the list of active codes of the official ISO 4217 currency names.  For the full list of active codes of the official ISO 4217 currencies, see: [https://www.iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html)  Examples:  | Option | Description | | ------ | ----------- | | EUR | Euro | | CHF | Swiss franc | | CAD | Canadian Dollar | | GBP | Pound sterling
   * @type {string}
   * @memberof ERoamingPricingProductDataPricingProductDataInner
   */
  PricingDefaultPriceCurrency: string;
  /**
   * Default Reference Unit in time or kWh  | Option | Description | | ------ | ----------- | | HOUR | Defined Reference Unit Type | | KILOWATT_HOUR | Defined Reference Unit Type | | MINUTE | Defined Reference Unit Type |
   * @type {string}
   * @memberof ERoamingPricingProductDataPricingProductDataInner
   */
  PricingDefaultReferenceUnit: string;
  /**
   * A list of pricing products
   * @type {Array<PricingProductDataRecord>}
   * @memberof ERoamingPricingProductDataPricingProductDataInner
   */
  PricingProductDataRecords: Array<PricingProductDataRecord>;
}
/**
 * eRoamingPullEVSEData is a message that is sent in order to request the download of EVSE data of operators stored on the Hubject system.
 * @export
 * @interface ERoamingPullEVSEData
 */
export interface ERoamingPullEVSEData {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingPullEVSEData
   */
  ProviderID: string;
  /**
   *
   * @type {ERoamingPullEVSEDataSearchCenter}
   * @memberof ERoamingPullEVSEData
   */
  SearchCenter?: ERoamingPullEVSEDataSearchCenter | null;
  /**
   *
   * @type {string}
   * @memberof ERoamingPullEVSEData
   */
  LastCall?: string | null;
  /**
   *
   * @type {GeoCoordinatesResponseFormat}
   * @memberof ERoamingPullEVSEData
   */
  GeoCoordinatesResponseFormat: GeoCoordinatesResponseFormat;
  /**
   *
   * @type {Array<string>}
   * @memberof ERoamingPullEVSEData
   */
  CountryCodes?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof ERoamingPullEVSEData
   */
  OperatorIds?: Array<string> | null;
  /**
   *
   * @type {Array<AuthenticationMode>}
   * @memberof ERoamingPullEVSEData
   */
  AuthenticationModes?: Array<AuthenticationMode> | null;
  /**
   *
   * @type {Array<Accessibility>}
   * @memberof ERoamingPullEVSEData
   */
  Accessibility?: Array<Accessibility> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof ERoamingPullEVSEData
   */
  CalibrationLawDataAvailability?: Array<string> | null;
  /**
   *
   * @type {boolean}
   * @memberof ERoamingPullEVSEData
   */
  RenewableEnergy?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof ERoamingPullEVSEData
   */
  IsHubjectCompatible?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof ERoamingPullEVSEData
   */
  IsOpen24Hours?: boolean | null;
}

/**
 * \"The data can be restricted using search parameters that are provided in this field.  Cannot be combined with “LastCall”.\"
 * @export
 * @interface ERoamingPullEVSEDataSearchCenter
 */
export interface ERoamingPullEVSEDataSearchCenter {
  /**
   *
   * @type {GeoCoordinates}
   * @memberof ERoamingPullEVSEDataSearchCenter
   */
  GeoCoordinates: GeoCoordinates;
  /**
   *
   * @type {Radius}
   * @memberof ERoamingPullEVSEDataSearchCenter
   */
  Radius: Radius;
}
/**
 * eRoamingPullEVSEPricing is a message that is sent in order to request the download of (i.e.pull) location/EVSE-specific pricing data uploaded by CPOs for the requesting EMP.
 * @export
 * @interface ERoamingPullEVSEPricing
 */
export interface ERoamingPullEVSEPricing {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingPullEVSEPricing
   */
  ProviderID: string;
  /**
   *
   * @type {string}
   * @memberof ERoamingPullEVSEPricing
   */
  LastCall?: string | null;
  /**
   * A list of Operator Ids in ISO or DIN standard to download pricing data pushed by one or more operators.
   * @type {Array<string>}
   * @memberof ERoamingPullEVSEPricing
   */
  OperatorIDs: Array<string>;
}
/**
 * eRoamingPullEVSEStatusByID is a message that is sent in order to request the EVSE status data for specific EVSE IDs.
 * @export
 * @interface ERoamingPullEVSEStatusByID
 */
export interface ERoamingPullEVSEStatusByID {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingPullEVSEStatusByID
   */
  ProviderID: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ERoamingPullEVSEStatusByID
   */
  EvseID: Array<string>;
}
/**
 * eRoamingPullEVSEStatusByOperatorID is a message that is sent in order to request the EVSE status data for specific OperatorsIDs (i.e. CPO(s) specific EVSE status data).
 * @export
 * @interface ERoamingPullEVSEStatusByOperatorID
 */
export interface ERoamingPullEVSEStatusByOperatorID {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingPullEVSEStatusByOperatorID
   */
  ProviderID: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ERoamingPullEVSEStatusByOperatorID
   */
  OperatorID: Array<string>;
}
/**
 * eRoamingPullEVSEStatus is a message that is sent in order to request the download of EVSE status data stored on the Hubject system  Tip:   * In case not all but a specific EVSE status is needed, Hubject offers the service eRoamingPullEVSEStatusByID and eRoamingPullEVSEStatusByOperatorID.   * We recommend a to send the request with a frequency from 1 to 5 minutes.
 * @export
 * @interface ERoamingPullEVSEStatusInput
 */
export interface ERoamingPullEVSEStatusInput {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingPullEVSEStatusInput
   */
  ProviderID: string;
  /**
   *
   * @type {ERoamingPullEVSEStatusSearchCenterInput}
   * @memberof ERoamingPullEVSEStatusInput
   */
  SearchCenter?: ERoamingPullEVSEStatusSearchCenterInput | null;
  /**
   *
   * @type {EvseStatus}
   * @memberof ERoamingPullEVSEStatusInput
   */
  EVSEStatus?: EvseStatus | null;
}

/**
 * eRoamingPullEVSEStatus is a message that is sent in order to request the download of EVSE status data stored on the Hubject system  Tip:   * In case not all but a specific EVSE status is needed, Hubject offers the service eRoamingPullEVSEStatusByID and eRoamingPullEVSEStatusByOperatorID.   * We recommend a to send the request with a frequency from 1 to 5 minutes.
 * @export
 * @interface ERoamingPullEVSEStatusOutput
 */
export interface ERoamingPullEVSEStatusOutput {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ERoamingPullEVSEStatusOutput
   */
  ProviderID: string;
  /**
   *
   * @type {ERoamingPullEVSEStatusSearchCenterOutput}
   * @memberof ERoamingPullEVSEStatusOutput
   */
  SearchCenter?: ERoamingPullEVSEStatusSearchCenterOutput | null;
  /**
   *
   * @type {EvseStatus}
   * @memberof ERoamingPullEVSEStatusOutput
   */
  EVSEStatus?: EvseStatus | null;
}

/**
 * The data can be restricted using search parameters that are provided in this field.
 * @export
 * @interface ERoamingPullEVSEStatusSearchCenterInput
 */
export interface ERoamingPullEVSEStatusSearchCenterInput {
  /**
   *
   * @type {GeoCoordinates}
   * @memberof ERoamingPullEVSEStatusSearchCenterInput
   */
  GeoCoordinates: GeoCoordinates;
  /**
   *
   * @type {Radius}
   * @memberof ERoamingPullEVSEStatusSearchCenterInput
   */
  Radius: Radius;
}
/**
 * The data can be restricted using search parameters that are provided in this field.
 * @export
 * @interface ERoamingPullEVSEStatusSearchCenterOutput
 */
export interface ERoamingPullEVSEStatusSearchCenterOutput {
  /**
   *
   * @type {GeoCoordinates}
   * @memberof ERoamingPullEVSEStatusSearchCenterOutput
   */
  GeoCoordinates: GeoCoordinates;
  /**
   *
   * @type {Radius}
   * @memberof ERoamingPullEVSEStatusSearchCenterOutput
   */
  Radius: Radius;
}
/**
 * eRoamingPullPricingProductData is a message that is sent in order to request the download of pricing data available in the HBS for an EMP.
 * @export
 * @interface ERoamingPullPricingProductData
 */
export interface ERoamingPullPricingProductData {
  /**
   *
   * @type {string}
   * @memberof ERoamingPullPricingProductData
   */
  LastCall?: string | null;
  /**
   * A list of Operator Ids in ISO or DIN standard to download pricing data pushed by one or more operators.
   * @type {Array<string>}
   * @memberof ERoamingPullPricingProductData
   */
  OperatorIDs: Array<string>;
}
/**
 * eRoamingPushAuthenticationData is a message that is sent in order to upload authentication data to Hubject.  Note: * This message is only for EMPs onboarded to the Hubject platform as offline EMPs.
 * @export
 * @interface ERoamingPushAuthenticationData
 */
export interface ERoamingPushAuthenticationData {
  /**
   * Describes the action that has to be performed by Hubject with the provided data.
   * @type {string}
   * @memberof ERoamingPushAuthenticationData
   */
  ActionType: string;
  /**
   *
   * @type {ProviderAuthenticationData}
   * @memberof ERoamingPushAuthenticationData
   */
  ProviderAuthenticationData: ProviderAuthenticationData;
}
/**
 * energy source that the charging station uses to supply electric energy
 * @export
 * @interface EnergySource
 */
export interface EnergySource {
  /**
   *
   * @type {string}
   * @memberof EnergySource
   */
  Energy?: string | null;
  /**
   *
   * @type {number}
   * @memberof EnergySource
   */
  Percentage?: number | null;
}
/**
 * | Option | Description |                 | ------ | ----------- | | Available | Charging Spot is available for charging. | | Reserved | Charging Spot is reserved and not available for charging. | | Occupied | Charging Spot is busy. | | OutOfService | Charging Spot is out of service and not available for charging. | | EvseNotFound | The requested EvseID and EVSE status does not exist within the Hubject database. | | Unknown | No status information available. |
 * @export
 * @enum {string}
 */

export const EvseStatus = {
  Available: "Available",
  Reserved: "Reserved",
  Occupied: "Occupied",
  OutOfService: "OutOfService",
  EvseNotFound: "EvseNotFound",
  Unknown: "Unknown",
} as const;

export type EvseStatus = (typeof EvseStatus)[keyof typeof EvseStatus];

/**
 * Important  __One of the following three options `MUST` be provided__
 * @export
 * @interface GeoCoordinates
 */
export interface GeoCoordinates {
  /**
   *
   * @type {GeoCoordinatesGoogle}
   * @memberof GeoCoordinates
   */
  Google?: GeoCoordinatesGoogle | null;
  /**
   *
   * @type {GeoCoordinatesDecimalDegree}
   * @memberof GeoCoordinates
   */
  DecimalDegree?: GeoCoordinatesDecimalDegree | null;
  /**
   *
   * @type {GeoCoordinatesDegreeMinuteSeconds}
   * @memberof GeoCoordinates
   */
  DegreeMinuteSeconds?: GeoCoordinatesDegreeMinuteSeconds | null;
}
/**
 * Geocoordinates using DecimalDegree Structure
 * @export
 * @interface GeoCoordinatesDecimalDegree
 */
export interface GeoCoordinatesDecimalDegree {
  /**
   * A string that `MUST` be valid with respect to the following regular expression:  `^-?1?\\d{1,2}\\.\\d{1,6}$` The expression validates the string as a geo coordinate (longitude or latitude) with decimal degree syntax.  Examples: “9.360922”, “-21.568201”
   * @type {string}
   * @memberof GeoCoordinatesDecimalDegree
   */
  Longitude: string;
  /**
   * A string that `MUST` be valid with respect to the following regular expression:  `^-?1?\\d{1,2}\\.\\d{1,6}$` The expression validates the string as a geo coordinate (longitude or latitude) with decimal degree syntax.  Examples: “9.360922”, “-21.568201”
   * @type {string}
   * @memberof GeoCoordinatesDecimalDegree
   */
  Latitude: string;
}
/**
 * Geocoordinates using DegreeMinutesSeconds Structure
 * @export
 * @interface GeoCoordinatesDegreeMinuteSeconds
 */
export interface GeoCoordinatesDegreeMinuteSeconds {
  /**
   * A string that `MUST` be valid with respect to the following regular expression:  `^-?1?\\d{1,2}°[ ]?\\d{1,2}\'[ ]?\\d{1,2}\\.\\d+\'\'$` The expression validates the string as a geo coordinate (longitude or latitude) consisting of degree, minutes, and seconds  Examples: “9°21\'39.32\'\'”, “-21°34\'23.16\'\'
   * @type {string}
   * @memberof GeoCoordinatesDegreeMinuteSeconds
   */
  Longitude: string;
  /**
   * A string that `MUST` be valid with respect to the following regular expression:  `^-?1?\\d{1,2}°[ ]?\\d{1,2}\'[ ]?\\d{1,2}\\.\\d+\'\'$` The expression validates the string as a geo coordinate (longitude or latitude) consisting of degree, minutes, and seconds  Examples: “9°21\'39.32\'\'”, “-21°34\'23.16\'\'
   * @type {string}
   * @memberof GeoCoordinatesDegreeMinuteSeconds
   */
  Latitude: string;
}
/**
 * Geocoordinates using Google Structure Based on WGS84
 * @export
 * @interface GeoCoordinatesGoogle
 */
export interface GeoCoordinatesGoogle {
  /**
   * A string that `MUST` be valid with respect to the following regular expression:  `^-?1?\\d{1,2}\\.\\d{1,6}\\s*\\,?\\s*-?1?\\d{1,2}\\.\\d{1,6}$` The expression validates the string as geo coordinates with respect to the Google standard. The string contains latitude and longitude (in this sequence) separated by a space.  Example: “47.662249 9.360922”
   * @type {string}
   * @memberof GeoCoordinatesGoogle
   */
  Coordinates: string;
}
/**
 * Defines the format of geo coordinates that shall be provided with the response.
 * @export
 * @enum {string}
 */

export const GeoCoordinatesResponseFormat = {
  Google: "Google",
  DegreeMinuteSeconds: "DegreeMinuteSeconds",
  DecimalDegree: "DecimalDegree",
} as const;

export type GeoCoordinatesResponseFormat =
  (typeof GeoCoordinatesResponseFormat)[keyof typeof GeoCoordinatesResponseFormat];

/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 * Authentication data  1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages. 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
 * @export
 * @interface IdentificationInput
 */
export interface IdentificationInput {
  /**
   *
   * @type {RFIDMifareFamilyIdentification}
   * @memberof IdentificationInput
   */
  RFIDMifareFamilyIdentification?: RFIDMifareFamilyIdentification | null;
  /**
   *
   * @type {RFIDIdentification}
   * @memberof IdentificationInput
   */
  RFIDIdentification?: RFIDIdentification | null;
  /**
   *
   * @type {QRCodeIdentificationInput}
   * @memberof IdentificationInput
   */
  QRCodeIdentification?: QRCodeIdentificationInput | null;
  /**
   *
   * @type {PlugAndChargeIdentification}
   * @memberof IdentificationInput
   */
  PlugAndChargeIdentification?: PlugAndChargeIdentification | null;
  /**
   *
   * @type {RemoteIdentification}
   * @memberof IdentificationInput
   */
  RemoteIdentification?: RemoteIdentification | null;
}
/**
 * Authentication data  1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages. 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
 * @export
 * @interface IdentificationOutput
 */
export interface IdentificationOutput {
  /**
   *
   * @type {RFIDMifareFamilyIdentification}
   * @memberof IdentificationOutput
   */
  RFIDMifareFamilyIdentification?: RFIDMifareFamilyIdentification | null;
  /**
   *
   * @type {RFIDIdentification}
   * @memberof IdentificationOutput
   */
  RFIDIdentification?: RFIDIdentification | null;
  /**
   *
   * @type {QRCodeIdentificationOutput}
   * @memberof IdentificationOutput
   */
  QRCodeIdentification?: QRCodeIdentificationOutput | null;
  /**
   *
   * @type {PlugAndChargeIdentification}
   * @memberof IdentificationOutput
   */
  PlugAndChargeIdentification?: PlugAndChargeIdentification | null;
  /**
   *
   * @type {RemoteIdentification}
   * @memberof IdentificationOutput
   */
  RemoteIdentification?: RemoteIdentification | null;
}
/**
 * InfoTextType
 * @export
 * @interface InfoTextType
 */
export interface InfoTextType {
  /**
   * `^[a-z]{2,3}(?:-[A-Z]{2,3}(?:-[a-zA-Z]{4})?)?(?:-x-[a-zA-Z0-9]{1,8})?$`  The language in which the additional info text is provided  The expression validates the string as a language code as per ISO-639-1 or ISO-639-2/T  The LanguageCodeType is used in the AdditionalInfo field, which is part of the EvseDataRecordType.
   * @type {string}
   * @memberof InfoTextType
   */
  lang: string;
  /**
   * The Additional Info text
   * @type {string}
   * @memberof InfoTextType
   */
  value: string;
}
/**
 * A value in kWh
 * @export
 * @interface Maximumproductchargingpower
 */
export interface Maximumproductchargingpower {}
/**
 * The ending meter value in kWh.
 * @export
 * @interface Metervalueend
 */
export interface Metervalueend {}
/**
 * The starting meter value in kWh.
 * @export
 * @interface Metervaluestart
 */
export interface Metervaluestart {}
/**
 * Total NuclearWaste emited by the energy source being used by this charging station to supply energy to EV. Units are in g/kWh
 * @export
 * @interface Nuclearwaste
 */
export interface Nuclearwaste {}
/**
 * OpeningTimes
 * @export
 * @interface OpeningTimes
 */
export interface OpeningTimes {
  /**
   * The starting and end time for pricing product applicability in the specified period
   * @type {Array<OpeningTimesPeriodInner>}
   * @memberof OpeningTimes
   */
  Period: Array<OpeningTimesPeriodInner>;
  /**
   * Day values to be used in specifying periods on which the product is available. Workdays = Monday – Friday, Weekend = Saturday – Sunday
   * @type {string}
   * @memberof OpeningTimes
   */
  on: string;
}
/**
 * OpeningTimesPeriodInner
 * @export
 * @interface OpeningTimesPeriodInner
 */
export interface OpeningTimesPeriodInner {
  /**
   * The opening time
   * @type {string}
   * @memberof OpeningTimesPeriodInner
   */
  begin: string;
  /**
   * The closing time
   * @type {string}
   * @memberof OpeningTimesPeriodInner
   */
  end: string;
}
/**
 * | Option | Description | | ------ | ----------- | | No payment | Free. | | Direct | e. g. Cash, Card, SMS, ... | | Contract | i. e. Subscription  |  Note  `No Payment` can not be combined with other payment option
 * @export
 * @enum {string}
 */

export const PaymentOption = {
  NoPayment: "No Payment",
  Direct: "Direct",
  Contract: "Contract",
} as const;

export type PaymentOption = (typeof PaymentOption)[keyof typeof PaymentOption];

/**
 * | Option | Description | |Small Paddle Inductive | Defined plug type. | | Large Paddle Inductive | Defined plug type.| | AVCON Connector | Defined plug type.| | Tesla Connector | Defined plug type.| | NEMA 5-20 | Defined plug type.| | Type E French Standard | CEE 7/5. | | Type F Schuko | CEE 7/4. | | Type G British Standard | BS 1363. | | Type J Swiss Standard | SEV 1011. | | Type 1 Connector (Cable Attached) | Cable attached to IEC 62196-1 type 1, SAE J1772 connector. | | Type 2 Outlet | IEC 62196-1 type 2. | | Type 2 Connector (Cable Attached) | Cable attached to IEC 62196-1 type 2 connector. | | Type 3 Outlet | IEC 62196-1 type 3. | | IEC 60309 Single Phase | IEC 60309. | | IEC 60309 Three Phase | IEC 60309. | | CCS Combo 2 Plug (Cable Attached) | IEC 62196-3 CDV DC Combined Charging Connector DIN SPEC 70121 refers to ISO / IEC 15118-1 DIS, -2 DIS and 15118-3. | | CCS Combo 1 Plug (Cable Attached) | IEC 62196-3 CDV DC Combined Charging Connector with IEC 62196-1 type 2 SAE J1772 connector. | | CHAdeMO | DC CHAdeMO Connector. |
 * @export
 * @enum {string}
 */

export const Plug = {
  SmallPaddleInductive: "Small Paddle Inductive",
  LargePaddleInductive: "Large Paddle Inductive",
  AvconConnector: "AVCON Connector",
  TeslaConnector: "Tesla Connector",
  Nema520: "NEMA 5-20",
  TypeEFrenchStandard: "Type E French Standard",
  TypeFSchuko: "Type F Schuko",
  TypeGBritishStandard: "Type G British Standard",
  TypeJSwissStandard: "Type J Swiss Standard",
  Type1ConnectorCableAttached: "Type 1 Connector (Cable Attached)",
  Type2Outlet: "Type 2 Outlet",
  Type2ConnectorCableAttached: "Type 2 Connector (Cable Attached)",
  Type3Outlet: "Type 3 Outlet",
  Iec60309SinglePhase: "IEC 60309 Single Phase",
  Iec60309ThreePhase: "IEC 60309 Three Phase",
  CcsCombo2PlugCableAttached: "CCS Combo 2 Plug (Cable Attached)",
  CcsCombo1PlugCableAttached: "CCS Combo 1 Plug (Cable Attached)",
  ChAdeMo: "CHAdeMO",
} as const;

export type Plug = (typeof Plug)[keyof typeof Plug];

/**
 * Authentication required for Plug&Charge (EMAID/EVCOID)
 * @export
 * @interface PlugAndChargeIdentification
 */
export interface PlugAndChargeIdentification {
  /**
   * A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  ^(([A-Za-z]{2}\\-?[A-Za-z0-9]{3}\\-?C[A-Za-z0-9]{8}\\-?[\\d|A-Za-z])|([A-Za-z]{2}[\\*|\\-]?[A-Za-z0-9]{3}[\\*|\\-]?[A-Za-z0-9]{6}[\\*|\\-]?[\\d|X]))$ The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.  In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.  Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”  Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
   * @type {string}
   * @memberof PlugAndChargeIdentification
   */
  EvcoID: string;
}
/**
 * A price in the given currency
 * @export
 * @interface Priceperadditionalreferenceunit
 */
export interface Priceperadditionalreferenceunit {}
/**
 * A price per reference unit
 * @export
 * @interface Priceperreferenceunit
 */
export interface Priceperreferenceunit {}
/**
 * PricingProductDataRecord
 * @export
 * @interface PricingProductDataRecord
 */
export interface PricingProductDataRecord {
  /**
   * The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length). | Option | Description | |--------|-------------| | Standard Price | Standard Price | | AC1 | Product for AC 1 Phase charging | | AC3 | Product for AC 3 Phase charging | | DC | Product for DC charging | | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
   * @type {string}
   * @memberof PricingProductDataRecord
   */
  ProductID: string;
  /**
   * Default Reference Unit in time or kWh  | Option | Description | | ------ | ----------- | | HOUR | Defined Reference Unit Type | | KILOWATT_HOUR | Defined Reference Unit Type | | MINUTE | Defined Reference Unit Type |
   * @type {string}
   * @memberof PricingProductDataRecord
   */
  ReferenceUnit: string;
  /**
   * The ProductPriceCurrencyType allows for the list of active codes of the official ISO 4217 currency names.  For the full list of active codes of the official ISO 4217 currencies, see: [https://www.iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html)  Examples:  | Option | Description | | ------ | ----------- | | EUR | Euro | | CHF | Swiss franc | | CAD | Canadian Dollar | | GBP | Pound sterling
   * @type {string}
   * @memberof PricingProductDataRecord
   */
  ProductPriceCurrency: string;
  /**
   *
   * @type {Priceperreferenceunit}
   * @memberof PricingProductDataRecord
   */
  PricePerReferenceUnit: Priceperreferenceunit;
  /**
   *
   * @type {Maximumproductchargingpower}
   * @memberof PricingProductDataRecord
   */
  MaximumProductChargingPower: Maximumproductchargingpower;
  /**
   * Set to TRUE if the respective pricing product is applicable 24 hours a day. If FALSE, the respective applicability times `SHOULD` be provided in the field “ProductAvailabilityTimes”.
   * @type {boolean}
   * @memberof PricingProductDataRecord
   */
  IsValid24hours: boolean;
  /**
   * A list indicating when the pricing product is applicable
   * @type {Array<PricingProductDataRecordProductAvailabilityTimesInner>}
   * @memberof PricingProductDataRecord
   */
  ProductAvailabilityTimes: Array<PricingProductDataRecordProductAvailabilityTimesInner>;
  /**
   *
   * @type {Array<PricingProductDataRecordAdditionalReferencesInner>}
   * @memberof PricingProductDataRecord
   */
  AdditionalReferences?: Array<PricingProductDataRecordAdditionalReferencesInner> | null;
}
/**
 * PricingProductDataRecordAdditionalReferencesInner
 * @export
 * @interface PricingProductDataRecordAdditionalReferencesInner
 */
export interface PricingProductDataRecordAdditionalReferencesInner {
  /**
   * Additional pricing components to be considered in addition to the base pricing  | Option | Description | | ------ | ----------- | | START FEE | Can be used in case a fixed fee is charged for the initiation of the charging session. This is a fee charged on top of the main base price defined in the field \"PricePerReferenceUnit\" for any particular pricing product. | | FIXED FEE | Can be used if a single price is charged irrespective of charging duration or energy consumption (for instance if all sessions are to be charged a single fixed fee). When used, the value set in the field \"PricePerReferenceUnit\" for the main base price of respective pricing product SHOULD be set to zero. | | PARKING FEE | Can be used in case sessions are to be charged for both parking and charging. When used, it needs to be specified in the corresponding service offer on the HBS Portal when parking applies (e.g. from session start to charging start and charging end to session end or for the entire session duration, or x-minutes after charging end, etc) | | MINIMUM FEE | Can be used in case there is a minimum fee to be paid for all charging sessions. When used, this implies that the eventual price to be paid cannot be less than this minimum fee but can however be a price above/greater than the minimum fee. | | MAXIMUM FEE | Can be used in case there is a maximum fee to be charged for all charging sessions. When used, this implies that the eventual price to be paid cannot be more than this maximum fee but can however be a price below/lower than the maximum fee. |
   * @type {string}
   * @memberof PricingProductDataRecordAdditionalReferencesInner
   */
  AdditionalReference: string;
  /**
   * Default Reference Unit in time or kWh  | Option | Description | | ------ | ----------- | | HOUR | Defined Reference Unit Type | | KILOWATT_HOUR | Defined Reference Unit Type | | MINUTE | Defined Reference Unit Type |
   * @type {string}
   * @memberof PricingProductDataRecordAdditionalReferencesInner
   */
  AdditionalReferenceUnit: string;
  /**
   *
   * @type {Priceperadditionalreferenceunit}
   * @memberof PricingProductDataRecordAdditionalReferencesInner
   */
  PricePerAdditionalReferenceUnit: Priceperadditionalreferenceunit;
}
/**
 * PricingProductDataRecordProductAvailabilityTimesInner
 * @export
 * @interface PricingProductDataRecordProductAvailabilityTimesInner
 */
export interface PricingProductDataRecordProductAvailabilityTimesInner {
  /**
   *
   * @type {Array<PricingProductDataRecordProductAvailabilityTimesInnerPeriodsInner>}
   * @memberof PricingProductDataRecordProductAvailabilityTimesInner
   */
  Periods: Array<PricingProductDataRecordProductAvailabilityTimesInnerPeriodsInner>;
  /**
   * Day values to be used in specifying periods on which the product is available. Workdays = Monday – Friday, Weekend = Saturday – Sunday
   * @type {string}
   * @memberof PricingProductDataRecordProductAvailabilityTimesInner
   */
  on: string;
}
/**
 * The starting and end time for pricing product applicability in the specified period
 * @export
 * @interface PricingProductDataRecordProductAvailabilityTimesInnerPeriodsInner
 */
export interface PricingProductDataRecordProductAvailabilityTimesInnerPeriodsInner {
  /**
   * The opening time
   * @type {string}
   * @memberof PricingProductDataRecordProductAvailabilityTimesInnerPeriodsInner
   */
  begin: string;
  /**
   * The closing time
   * @type {string}
   * @memberof PricingProductDataRecordProductAvailabilityTimesInnerPeriodsInner
   */
  end: string;
}
/**
 * A default price for pricing sessions at undefined EVSEs
 * @export
 * @interface Pricingdefaultprice
 */
export interface Pricingdefaultprice {}
/**
 * ProviderAuthenticationData
 * @export
 * @interface ProviderAuthenticationData
 */
export interface ProviderAuthenticationData {
  /**
   * The ProviderID is defined by Hubject and is used to identify the EMP  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN  `^([A-Za-z]{2}\\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\\*|-]?[A-Za-z0-9]{3})$`  The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.  Examples ISO: “DE8EO”, “DE-8EO”  Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
   * @type {string}
   * @memberof ProviderAuthenticationData
   */
  ProviderID: string;
  /**
   *
   * @type {Array<ProviderAuthenticationDataAuthenticationDataRecordInner>}
   * @memberof ProviderAuthenticationData
   */
  AuthenticationDataRecord: Array<ProviderAuthenticationDataAuthenticationDataRecordInner>;
}
/**
 * ProviderAuthenticationDataAuthenticationDataRecordInner
 * @export
 * @interface ProviderAuthenticationDataAuthenticationDataRecordInner
 */
export interface ProviderAuthenticationDataAuthenticationDataRecordInner {
  /**
   *
   * @type {IdentificationInput}
   * @memberof ProviderAuthenticationDataAuthenticationDataRecordInner
   */
  Identification: IdentificationInput;
}
/**
 * PullEvseDataRecord
 * @export
 * @interface PullEvseDataRecord
 */
export interface PullEvseDataRecord {
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  deltaType?: string | null;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  lastUpdate?: string | null;
  /**
   * The ID that identifies the charging spot.  A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  `^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3}\\*?E[A-Za-z0-9\\*]{1,30})|(\\+?[0-9]{1,3}\\*[0-9]{3}\\*[0-9\\*]{1,32}))$` The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.  In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”  Example DIN: “+49*810*000*438”
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  EvseID: string;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  ChargingPoolID?: string | null;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  ChargingStationId?: string | null;
  /**
   * Name of the charging station
   * @type {Array<InfoTextType>}
   * @memberof PullEvseDataRecord
   */
  ChargingStationNames: Array<InfoTextType>;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  HardwareManufacturer?: string | null;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  ChargingStationImage?: string | null;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  SubOperatorName?: string | null;
  /**
   *
   * @type {AddressIso19773}
   * @memberof PullEvseDataRecord
   */
  Address: AddressIso19773;
  /**
   *
   * @type {GeoCoordinates}
   * @memberof PullEvseDataRecord
   */
  GeoCoordinates: GeoCoordinates;
  /**
   * List of plugs that are supported.
   * @type {Array<Plug>}
   * @memberof PullEvseDataRecord
   */
  Plugs: Array<Plug>;
  /**
   *
   * @type {boolean}
   * @memberof PullEvseDataRecord
   */
  DynamicPowerLevel?: boolean | null;
  /**
   * List of facilities that are supported.
   * @type {Array<ChargingFacility>}
   * @memberof PullEvseDataRecord
   */
  ChargingFacilities: Array<ChargingFacility>;
  /**
   * If the Charging Station provides only renewable energy then the value `MUST` be ”true”, if it use grey energy then value `MUST` be “false”.
   * @type {boolean}
   * @memberof PullEvseDataRecord
   */
  RenewableEnergy: boolean;
  /**
   *
   * @type {Array<EnergySource>}
   * @memberof PullEvseDataRecord
   */
  EnergySource?: Array<EnergySource> | null;
  /**
   *
   * @type {PullEvseDataRecordEnvironmentalImpact}
   * @memberof PullEvseDataRecord
   */
  EnvironmentalImpact?: PullEvseDataRecordEnvironmentalImpact | null;
  /**
   * | Option | Description | | Local | Calibration law data is shown at the charging station. | | External | Calibration law data is provided externaly. | | Not Available | Calibration law data is not provided. |
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  CalibrationLawDataAvailability: string;
  /**
   * List of authentication modes that are supported.
   * @type {Array<AuthenticationMode>}
   * @memberof PullEvseDataRecord
   */
  AuthenticationModes: Array<AuthenticationMode>;
  /**
   *
   * @type {number}
   * @memberof PullEvseDataRecord
   */
  MaxCapacity?: number | null;
  /**
   * List of payment options that are supported.
   * @type {Array<PaymentOption>}
   * @memberof PullEvseDataRecord
   */
  PaymentOptions: Array<PaymentOption>;
  /**
   * List of value added services that are supported.
   * @type {Array<ValueAddedService>}
   * @memberof PullEvseDataRecord
   */
  ValueAddedServices: Array<ValueAddedService>;
  /**
   *
   * @type {Accessibility}
   * @memberof PullEvseDataRecord
   */
  Accessibility: Accessibility;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  AccessibilityLocation?: string | null;
  /**
   * `^\\+[0-9]{5,15}$` The expression validates the string as a telephone number starting with “+” and containing only numbers.  Example: “+0305132787”
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  HotlinePhoneNumber: string;
  /**
   *
   * @type {Array<InfoTextType>}
   * @memberof PullEvseDataRecord
   */
  AdditionalInfo?: Array<InfoTextType> | null;
  /**
   *
   * @type {Array<InfoTextType>}
   * @memberof PullEvseDataRecord
   */
  ChargingStationLocationReference?: Array<InfoTextType> | null;
  /**
   *
   * @type {GeoCoordinates}
   * @memberof PullEvseDataRecord
   */
  GeoChargingPointEntrance?: GeoCoordinates | null;
  /**
   * Set in case the charging spot is open 24 hours.
   * @type {boolean}
   * @memberof PullEvseDataRecord
   */
  IsOpen24Hours: boolean;
  /**
   *
   * @type {Array<OpeningTimes>}
   * @memberof PullEvseDataRecord
   */
  OpeningTimes?: Array<OpeningTimes> | null;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  HubOperatorID?: string | null;
  /**
   *
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  ClearinghouseID?: string | null;
  /**
   * Is eRoaming via intercharge at this charging station possible? If set to \"false\" the charge spot will not be started/stopped remotely via Hubject.
   * @type {boolean}
   * @memberof PullEvseDataRecord
   */
  IsHubjectCompatible: boolean;
  /**
   * Values: true / false / auto This attribute indicates whether a CPO provides (dynamic) EVSE Status info in addition to the (static) EVSE Data for this EVSERecord. Value auto is set to true by Hubject if the operator offers Hubject EVSEStatus data.
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  DynamicInfoAvailable: string;
  /**
   * A string that MUST be valid with respect to the following regular expression: ISO | DIN  ^(([A-Za-z]{2}\\*?[A-Za-z0-9]{3})|(\\+?[0-9]{1,3}\\*[0-9]{3}))$ The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.  In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.  Examples ISO: “DE*A36”, “DEA36”  Example DIN: “+49*536”
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  OperatorID: string;
  /**
   * Free text for operator
   * @type {string}
   * @memberof PullEvseDataRecord
   */
  OperatorName: string;
}

/**
 * PullEvseDataRecordEnvironmentalImpact
 * @export
 * @interface PullEvseDataRecordEnvironmentalImpact
 */
export interface PullEvseDataRecordEnvironmentalImpact {
  /**
   *
   * @type {Co2Emission}
   * @memberof PullEvseDataRecordEnvironmentalImpact
   */
  CO2Emission?: Co2Emission | null;
  /**
   *
   * @type {Nuclearwaste}
   * @memberof PullEvseDataRecordEnvironmentalImpact
   */
  NuclearWaste?: Nuclearwaste | null;
}
/**
 * QRCodeIdentificationHashedPIN
 * @export
 * @interface QRCodeIdentificationHashedPIN
 */
export interface QRCodeIdentificationHashedPIN {
  /**
   * Hash value created by partner  The expression validates the string as a hash function result value with a length between 10 and 100 characters  Example: “a5ghdhf73h”
   * @type {string}
   * @memberof QRCodeIdentificationHashedPIN
   */
  Value: string;
  /**
   * Function that was used to generate the hash value.
   * @type {string}
   * @memberof QRCodeIdentificationHashedPIN
   */
  Function: string;
  /**
   *
   * @type {QRCodeIdentificationHashedPINLegacyHashData}
   * @memberof QRCodeIdentificationHashedPIN
   */
  LegacyHashData?: QRCodeIdentificationHashedPINLegacyHashData | null;
}
/**
 * QRCodeIdentificationHashedPINLegacyHashData
 * @export
 * @interface QRCodeIdentificationHashedPINLegacyHashData
 */
export interface QRCodeIdentificationHashedPINLegacyHashData {
  /**
   * Function used for hashing of the PIN at the partner.
   * @type {string}
   * @memberof QRCodeIdentificationHashedPINLegacyHashData
   */
  Function: string;
  /**
   *
   * @type {string}
   * @memberof QRCodeIdentificationHashedPINLegacyHashData
   */
  Salt?: string | null;
  /**
   *
   * @type {string}
   * @memberof QRCodeIdentificationHashedPINLegacyHashData
   */
  Value?: string | null;
}
/**
 * QRCodeIdentification
 * @export
 * @interface QRCodeIdentificationInput
 */
export interface QRCodeIdentificationInput {
  /**
   * A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  ^(([A-Za-z]{2}\\-?[A-Za-z0-9]{3}\\-?C[A-Za-z0-9]{8}\\-?[\\d|A-Za-z])|([A-Za-z]{2}[\\*|\\-]?[A-Za-z0-9]{3}[\\*|\\-]?[A-Za-z0-9]{6}[\\*|\\-]?[\\d|X]))$ The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.  In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.  Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”  Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
   * @type {string}
   * @memberof QRCodeIdentificationInput
   */
  EvcoID: string;
  /**
   *
   * @type {QRCodeIdentificationHashedPIN}
   * @memberof QRCodeIdentificationInput
   */
  HashedPIN?: QRCodeIdentificationHashedPIN | null;
  /**
   *
   * @type {string}
   * @memberof QRCodeIdentificationInput
   */
  PIN?: string | null;
}
/**
 * QRCodeIdentification
 * @export
 * @interface QRCodeIdentificationOutput
 */
export interface QRCodeIdentificationOutput {
  /**
   * A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  ^(([A-Za-z]{2}\\-?[A-Za-z0-9]{3}\\-?C[A-Za-z0-9]{8}\\-?[\\d|A-Za-z])|([A-Za-z]{2}[\\*|\\-]?[A-Za-z0-9]{3}[\\*|\\-]?[A-Za-z0-9]{6}[\\*|\\-]?[\\d|X]))$ The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.  In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.  Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”  Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
   * @type {string}
   * @memberof QRCodeIdentificationOutput
   */
  EvcoID: string;
  /**
   *
   * @type {QRCodeIdentificationHashedPIN}
   * @memberof QRCodeIdentificationOutput
   */
  HashedPIN?: QRCodeIdentificationHashedPIN | null;
  /**
   *
   * @type {string}
   * @memberof QRCodeIdentificationOutput
   */
  PIN?: string | null;
}
/**
 * Authentication data details. The data structure differs depending on the authentication technology
 * @export
 * @interface RFIDIdentification
 */
export interface RFIDIdentification {
  /**
   * Authentication data details. The data structure differs depending on the authentication technology  The expression validates the string as a unique RFID with a length of 8, 14 or 20 characters.  Examples: “7568290FFF765F”
   * @type {string}
   * @memberof RFIDIdentification
   */
  UID: string;
  /**
   *
   * @type {string}
   * @memberof RFIDIdentification
   */
  EvcoID?: string | null;
  /**
   * Defined RFID Type
   * @type {string}
   * @memberof RFIDIdentification
   */
  RFID: string;
  /**
   *
   * @type {string}
   * @memberof RFIDIdentification
   */
  PrintedNumber?: string | null;
  /**
   *
   * @type {string}
   * @memberof RFIDIdentification
   */
  ExpiryDate?: string | null;
}
/**
 * Authentication data details. The data structure differs depending on the authentication technology
 * @export
 * @interface RFIDMifareFamilyIdentification
 */
export interface RFIDMifareFamilyIdentification {
  /**
   * Authentication data details. The data structure differs depending on the authentication technology  The expression validates the string as a unique RFID with a length of 8, 14 or 20 characters.  Examples: “7568290FFF765F”
   * @type {string}
   * @memberof RFIDMifareFamilyIdentification
   */
  UID: string;
}
/**
 * Radius in km around the position that is defined by the geo coordinates
 * @export
 * @interface Radius
 */
export interface Radius {}
/**
 * Authentication data details. The data structure differs depending on the authentication technology
 * @export
 * @interface RemoteIdentification
 */
export interface RemoteIdentification {
  /**
   * A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.  ^(([A-Za-z]{2}\\-?[A-Za-z0-9]{3}\\-?C[A-Za-z0-9]{8}\\-?[\\d|A-Za-z])|([A-Za-z]{2}[\\*|\\-]?[A-Za-z0-9]{3}[\\*|\\-]?[A-Za-z0-9]{6}[\\*|\\-]?[\\d|X]))$ The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.  In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.  In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.  Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”  Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
   * @type {string}
   * @memberof RemoteIdentification
   */
  EvcoID: string;
}
/**
 * The structure consists of a defined code, an optional functional description of the status, and optional additional information. It can be used e.g. to send error details or detailed reasons for a certain process or system behavior. The optional AdditionalInfo field can be used in order to provide further individual (non-standardized) information.
 * @export
 * @interface StatusCode
 */
export interface StatusCode {
  /**
   * | Option | Description | Area of Usage | | -------|-------------|---------------| | 000 | Success. | General codes | | 001 | Hubject system error. | Internal system codes | | 002 | Hubject database error. |Internal system codes| | 009 |Data transaction error. | Internal system codes| |017 |Unauthorized Access. |Internal system codes | |018 |Inconsistent EvseID. |Internal system codes | |019 |Inconsistent EvcoID. |Internal system codes | |021 |System error. |General codes | |022 |Data error. |General codes | |101 |QR Code Authentication failed – Invalid Credentials. |Authentication codes | |102 |RFID Authentication failed – invalid UID. |Authentication codes | |103 |RFID Authentication failed – card not readable. |Authentication codes | |105 |PLC Authentication failed - invalid EvcoID. |Authentication codes | |106 |No positive authentication response. |Authentication codes / Internal system codes | |110 |QR Code App Authentication failed – time out error. |Authentication codes | |120 |PLC (ISO/ IEC 15118) Authentication failed – invalid underlying EvcoID. |Authentication codes | |121 |PLC (ISO/ IEC 15118) Authentication failed – invalid certificate. |Authentication codes | |122 |PLC (ISO/ IEC 15118) Authentication failed – time out error. |Authentication codes | |200 |EvcoID locked. |Authentication codes | |210 |No valid contract. |Session codes | |300 |Partner not found. |Session codes | |310 |Partner did not respond. |Session codes | |320 |Service not available. |Session codes | |400 |Session is invalid. |Session codes | |501 |Communication to EVSE failed. |EVSE codes | |510 |No EV connected to EVSE. |EVSE codes | |601 |EVSE already reserved. |EVSE codes | |602 |EVSE already in use/ wrong token. |EVSE codes | |603 |Unknown EVSE ID. |EVSE codes | |604 |EVSE ID is not Hubject compatible. |EVSE codes | |700 |EVSE out of service. |EVSE codes |
   * @type {string}
   * @memberof StatusCode
   */
  Code: string;
  /**
   *
   * @type {string}
   * @memberof StatusCode
   */
  Description?: string | null;
  /**
   *
   * @type {string}
   * @memberof StatusCode
   */
  AdditionalInfo?: string | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<ValidationErrorLocInner>}
   * @memberof ValidationError
   */
  loc: Array<ValidationErrorLocInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}
/**
 * | Option | Description | | ------ | ----------- | | Reservation | Can an EV driver reserve the charging sport via remote services? | | DynamicPricing | Does the EVSE ID support dynamic pricing? | | ParkingSensors | Is dynamic status info on the parking area in front of the EVSE-ID available? | | MaximumPowerCharging | Does the EVSE-ID offer a dynamic maximum power charging? | | PredictiveChargePointUsage | Is predictive charge Point usage info available for the EVSE-ID? | | ChargingPlans | Does the EVSE-ID offer charging plans, e.g. As described in ISO15118-2? | | RoofProvided | Indicates if the charging station is under a roof | | None | There are no value-added services available. |
 * @export
 * @enum {string}
 */

export const ValueAddedService = {
  Reservation: "Reservation",
  DynamicPricing: "DynamicPricing",
  ParkingSensors: "ParkingSensors",
  MaximumPowerCharging: "MaximumPowerCharging",
  PredictiveChargePointUsage: "PredictiveChargePointUsage",
  ChargingPlans: "ChargingPlans",
  RoofProvided: "RoofProvided",
  None: "None",
} as const;

export type ValueAddedService =
  (typeof ValueAddedService)[keyof typeof ValueAddedService];

/**
 * EMPOICPClientAPIApi - axios parameter creator
 * @export
 */
export const EMPOICPClientAPIApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`   * This operation is used by EMPs in order to remotely reserve a charging point.  ![Reservation start diagram](images/reservationstart.png)  __Functional Description:__  Scenario:  A customer of an EMP wants to reserve a charging point of a CPO for a later charging process. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a reservation of the CPO’s charging point by sending an eRoamingAuthorizeRemoteReservationStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID. The demanded reservation product can be specified using the field PartnerProductID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service Reservation (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the reservation process and forwards the request (including the SessionID) to the CPO. The CPO MUST return an eRoamingAcknowledgement message that MUST contain the result indicating whether the reservation was successful and that MAY contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.
     * @summary Eroamingauthorizeremotereservationstart V11
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteReservationStart} [eRoamingAuthorizeRemoteReservationStart]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post:
      async (
        providerID?: string,
        eRoamingAuthorizeRemoteReservationStart?: ERoamingAuthorizeRemoteReservationStart,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        const localVarPath = `/authorizeremotereservationstartv11`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (providerID !== undefined) {
          localVarQueryParameter["providerID"] = providerID;
        }

        localVarHeaderParameter["Content-Type"] = "application/json";

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };
        localVarRequestOptions.data = serializeDataIfNeeded(
          eRoamingAuthorizeRemoteReservationStart,
          localVarRequestOptions,
          configuration
        );

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Reservation stop diagram](images/reservationstop.png)  eRoamingAuthorizeRemoteReservationStop basically works in the same way as eRoamingAuthorizeRemoteReservationStart. The only difference is that this request is sent in order to end the reservation of a charging spot. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteReservationStart request. After the eRoamingAuthorizeRemoteReservationStop the CPO `MUST` provide a CDR.
     * @summary Eroamingauthorizeremotereservationstop V1
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteReservationStop} [eRoamingAuthorizeRemoteReservationStop]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post:
      async (
        providerID?: string,
        eRoamingAuthorizeRemoteReservationStop?: ERoamingAuthorizeRemoteReservationStop,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        const localVarPath = `/authorizeremotereservationstopv1`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (providerID !== undefined) {
          localVarQueryParameter["providerID"] = providerID;
        }

        localVarHeaderParameter["Content-Type"] = "application/json";

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };
        localVarRequestOptions.data = serializeDataIfNeeded(
          eRoamingAuthorizeRemoteReservationStop,
          localVarRequestOptions,
          configuration
        );

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`   * This operation is used by EMPs in order to remotely start a charging process  The service that is offered by Hubject in order to allow customers to directly start a charging process via mobile app.  ![Remote start diagram](images/remotestart.png)   __Functional Description:__  __Scenario:__  A customer of an EMP wants to charge a vehicle at a charging station of a CPO. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a charging process at the CPO’s charging station by sending an eRoamingAuthorizeRemoteStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the following process and forwards the request (including the SessionID) to the CPO. The CPO `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the charging process will be started and that `MAY` contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.  Best Practices:   * Please ensure a request run time of under 10 seconds including network roundtrip.
     * @summary Eroamingauthorizeremotestart V21
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteStart} [eRoamingAuthorizeRemoteStart]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post: async (
      providerID?: string,
      eRoamingAuthorizeRemoteStart?: ERoamingAuthorizeRemoteStart,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/authorizeremotestartv21`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (providerID !== undefined) {
        localVarQueryParameter["providerID"] = providerID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingAuthorizeRemoteStart,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Remote stop diagram](images/remotestop.png)  eRoamingAuthorizeRemoteStop basically works in the same way as eRoamingAuthorizeRemoteStart. The only difference is that this request is sent in order to initiate the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteStart request.
     * @summary Eroamingauthorizeremotestop V21
     * @param {string} [externalID]
     * @param {ERoamingAuthorizeRemoteStop} [eRoamingAuthorizeRemoteStop]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post: async (
      externalID?: string,
      eRoamingAuthorizeRemoteStop?: ERoamingAuthorizeRemoteStop,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/authorizeremotestopv21`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (externalID !== undefined) {
        localVarQueryParameter["externalID"] = externalID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingAuthorizeRemoteStop,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: EMP Online `OPTIONAL`, EMP Offline `MANDATORY`  ![Get Charge Detail Records diagram](images/getcdr.png)  The operation allows EMPs to download CDRs that have been sent to Hubject by partner CPOs. This means if for example Hubject was unable to forward a CDR from a CPO to an EMP due to technical problems in the EMP’s backend, the EMP will still have the option of obtaining these CDRs. The EMP `MUST` specify a date range in the request. Hubject will return a list of all CDRs received by the HBS within the specified date range for the requesting EMP (i.e. all CDRs within the date range where the corresponding charging process was authorized by the EMP or authorized by Hubject based on the EMP’s authentication data.  Hubject does not check whether a requested CDR has already been provided to the requesting EMP in the past.  Pagination:  Starting from OICP 2.3, eRoaminGetChargeDetailRecords uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of ChargeDetailRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Example:  Using OICP 2.3 GetChargeDetailRecords endpoint for PROD environment:  https://service.hubject.com/api/oicp/cdrmgmt/v22/providers/{providerID}/get-charge-detail-records-request?page=0&amp;size=1500  In the previous request we are telling to provide page __0__ with __1500__ records in it.  Important  The default number of records provided in the response are __20__ elements and the maximum number of records possible to obtain per page are __2000__.
     * @summary Eroaminggetchargedetailrecords V22
     * @param {string} [providerID]
     * @param {ERoamingGetChargeDetailRecords} [eRoamingGetChargeDetailRecords]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post: async (
      providerID?: string,
      eRoamingGetChargeDetailRecords?: ERoamingGetChargeDetailRecords,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/getchargedetailrecordsv22`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (providerID !== undefined) {
        localVarQueryParameter["providerID"] = providerID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingGetChargeDetailRecords,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`  When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of EVSE pricing data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid EVSE pricing data available in the HBS for the requesting EMP are grouped by OperatorID and sent in response to the request.  The operation also allows the use of the LastCall filter. When the LastCall filter is used, only EVSE pricing data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
     * @summary Eroamingpullevsepricing V10
     * @param {string} [providerID]
     * @param {ERoamingPullEVSEPricing} [eRoamingPullEVSEPricing]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullEVSEPricingV10Pullevsepricingv10Post: async (
      providerID?: string,
      eRoamingPullEVSEPricing?: ERoamingPullEVSEPricing,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/pullevsepricingv10`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (providerID !== undefined) {
        localVarQueryParameter["providerID"] = providerID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingPullEVSEPricing,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Pull evse data diagram](images/pullevsedata.png)  When an EMP sends an eRoamingPullEVSEData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSEData from Hubject. When an EMP sends an eRoamingPullEVSEData request, Hubject identifies all currently valid EVSEData records of all operators.  For every EVSE data record Hubject identifies the timestamp of the last update, which has been performed on the record. The timestamp is returned with the attribute “lastUpdate”.  __Delta pull:__  As mentioned above, the operation by default returns all currently valid EVSE data records. However, the requesting EMP has the possibility to download only the changes (delta) compared to a certain time in the past. In order to do so, the EMP MUST provide the optional date/time field “LastCall”, indicating his last EVSE pull request. In case that Hubject receives the LastCall parameter, Hubject compares the EVSE records from the time of the last call with the currently valid records. As a result, Hubject assigns the attribute “deltaType” (possible values: insert, update, delete) to every response EVSE data record indicating whether the particular record has been inserted, updated or deleted in the meantime. EVSE data records that have not changed will not be part of the response.  Note: * The delta pull option cannot be combined with radial search, because in some cases this could lead to data inconsistency on the EMP’s side. This is why the API only allows the provision of either the attribute “SearchCenter” or “LastCall”.  __Pagination:__  Starting from OICP 2.3, eRoamingPullEvseData uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of EvseDataRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Important: * __The default number of records provided in the eRoamingEvseData response is 20 elements.__
     * @summary Eroamingpullevsedata V23
     * @param {string} [providerID]
     * @param {ERoamingPullEVSEData} [eRoamingPullEVSEData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullEvseDataV23Pullevsedatav23Post: async (
      providerID?: string,
      eRoamingPullEVSEData?: ERoamingPullEVSEData,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/pullevsedatav23`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (providerID !== undefined) {
        localVarQueryParameter["providerID"] = providerID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingPullEVSEData,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `Mandatory`  ![Pull EVSE status](images/pullevsestatus.png)  When an EMP sends an eRoamingPullEVSEStatus request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSE status data from Hubject. When an EMP sends an eRoamingPullEVSEStatus request, Hubject identifies all currently valid EVSE status records of all operators.  Hubject groups all resulting EVSE status records according to the related CPO. The response structure contains an “EvseStatuses” node that envelopes an “OperatorEVSEStatus” node for every CPO with currently valid and accessible status data records.
     * @summary Eroamingpullevsestatus V21
     * @param {string} [providerID]
     * @param {Body} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullEvseStatusV21Pullevsestatusv21Post: async (
      providerID?: string,
      body?: Body,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/pullevsestatusv21`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (providerID !== undefined) {
        localVarQueryParameter["providerID"] = providerID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`    When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of pricing product data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid pricing products data available in the HBS for the requesting EMP (and pushed by CPOs whose OperatorIDs are supplied in the request) are grouped by OperatorID and sent in response to the request.    The operation also allows the use of the LastCall filter. When the LastCall filter is used, only pricing product data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
     * @summary Eroamingpullpricingproductdata V10
     * @param {string} [providerID]
     * @param {ERoamingPullPricingProductData} [eRoamingPullPricingProductData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post: async (
      providerID?: string,
      eRoamingPullPricingProductData?: ERoamingPullPricingProductData,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/pullpricingproductdatav10`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (providerID !== undefined) {
        localVarQueryParameter["providerID"] = providerID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingPullPricingProductData,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Push authentication data diagram](images/pushauthentificationdata.png)  When an EMP sends an eRoamingPushAuthenticationData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (Hubject must be the subscriber). If so, the operation allows uploading authentication data to Hubject. Furthermore, it is possible to update authentication data that has been pushed with an earlier operation request. How Hubject handles the transferred data `MUST` be defined in the request field “ActionType”, which offers four options (see below).  The authentication data to be inserted or updated `MUST` be provided with the “ProviderAuthenticationData” field, which consists of “AuthenticationDataRecord” structures. Hubject keeps a history of all updated and changed data records. Every successful push operation – irrespective of the performed action – leads to a new version of currently valid data records. Furthermore, each operation is logged with the current timestamp. Thus, Hubject can reconstruct the status of authentication data for every point in time in the past.  __Action types:__  * __fullLoad:__ The EMP uploads the full set of current authentication data. Hubject does not compare the new data to old (earlier pushed) data. It keeps a history of old data records and handles the newly provided data as valid. In order to allow an easy deletion of all records, it is possible to perform a fullLoad with an empty list of records.  * __insert:__ The EMP adds further authentication data records to the current set of data. Hubject verifies that the provided data records do not already exist in the currently valid data status. If so, the transaction will be aborted, no data will be inserted, and the request will be answered with an error message. Error details will be provided with the “AdditionalInfo” field.  * __update:__ The EMP updates data records of the current set of data. Hubject verifies that the provided data records do exist in the currently valid data status. If not, the transaction will be aborted, no data will be updated, and the request will be answered with an error message.  * __delete:__ The EMP deletes data records of the current set of data.  __PIN security:__  The authentication data records that are uploaded to Hubject contain one of the defined identification types. The identification type “QRCodeIdentificationType” contains – besides an “EvcoID” field – a “PIN” field or a “HashedPIN” field (only one of the two options must be provided). For security reasons, Hubject generally does not store PINs in clear text, but always as encrypted hash values. When uploading authentication data to Hubject, the EMPs can directly provide hashed PIN values (using the field “HashedPIN”). In case that the PINs are provided in clear text (field “PIN”), Hubject will generate a hash value for every PIN and will store only the hashes. Hubject by default generates a hash using Bcrypt as a hashing function.  In case that an EMP provides already hashed PINs, he `MUST` also specify the corresponding hash generation algorithm so that Hubject can reproduce the hash generation when processing a request for authorization. For this reason, the “HashedPIN” field contains detailed information concerning the hash function and the hash salt value (for salted hash functions) that must be used for hash generation.  __EVCO consistency:__  EvcoIDs contain the ID of the corresponding EMP. With every data upload operation Hubject checks whether the given EMP’s ProviderID (or Sub-ProviderIDs if necessary) matches every given EvcoID. If not, Hubject refuses the data upload and responds with the status code 019.  Note:  The eRoamingPushAuthenticationData operation `MUST` always be used sequentially.
     * @summary Eroamingpushauthenticationdata V21
     * @param {string} [providerID]
     * @param {ERoamingPushAuthenticationData} [eRoamingPushAuthenticationData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post: async (
      providerID?: string,
      eRoamingPushAuthenticationData?: ERoamingPushAuthenticationData,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/pushauthenticationdatav21`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (providerID !== undefined) {
        localVarQueryParameter["providerID"] = providerID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingPushAuthenticationData,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EMPOICPClientAPIApi - functional programming interface
 * @export
 */
export const EMPOICPClientAPIApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EMPOICPClientAPIApiAxiosParamCreator(configuration);
  return {
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`   * This operation is used by EMPs in order to remotely reserve a charging point.  ![Reservation start diagram](images/reservationstart.png)  __Functional Description:__  Scenario:  A customer of an EMP wants to reserve a charging point of a CPO for a later charging process. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a reservation of the CPO’s charging point by sending an eRoamingAuthorizeRemoteReservationStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID. The demanded reservation product can be specified using the field PartnerProductID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service Reservation (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the reservation process and forwards the request (including the SessionID) to the CPO. The CPO MUST return an eRoamingAcknowledgement message that MUST contain the result indicating whether the reservation was successful and that MAY contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.
     * @summary Eroamingauthorizeremotereservationstart V11
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteReservationStart} [eRoamingAuthorizeRemoteReservationStart]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post(
      providerID?: string,
      eRoamingAuthorizeRemoteReservationStart?: ERoamingAuthorizeRemoteReservationStart,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAcknowledgment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post(
          providerID,
          eRoamingAuthorizeRemoteReservationStart,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Reservation stop diagram](images/reservationstop.png)  eRoamingAuthorizeRemoteReservationStop basically works in the same way as eRoamingAuthorizeRemoteReservationStart. The only difference is that this request is sent in order to end the reservation of a charging spot. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteReservationStart request. After the eRoamingAuthorizeRemoteReservationStop the CPO `MUST` provide a CDR.
     * @summary Eroamingauthorizeremotereservationstop V1
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteReservationStop} [eRoamingAuthorizeRemoteReservationStop]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post(
      providerID?: string,
      eRoamingAuthorizeRemoteReservationStop?: ERoamingAuthorizeRemoteReservationStop,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAcknowledgment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post(
          providerID,
          eRoamingAuthorizeRemoteReservationStop,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`   * This operation is used by EMPs in order to remotely start a charging process  The service that is offered by Hubject in order to allow customers to directly start a charging process via mobile app.  ![Remote start diagram](images/remotestart.png)   __Functional Description:__  __Scenario:__  A customer of an EMP wants to charge a vehicle at a charging station of a CPO. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a charging process at the CPO’s charging station by sending an eRoamingAuthorizeRemoteStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the following process and forwards the request (including the SessionID) to the CPO. The CPO `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the charging process will be started and that `MAY` contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.  Best Practices:   * Please ensure a request run time of under 10 seconds including network roundtrip.
     * @summary Eroamingauthorizeremotestart V21
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteStart} [eRoamingAuthorizeRemoteStart]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post(
      providerID?: string,
      eRoamingAuthorizeRemoteStart?: ERoamingAuthorizeRemoteStart,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAcknowledgment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post(
          providerID,
          eRoamingAuthorizeRemoteStart,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Remote stop diagram](images/remotestop.png)  eRoamingAuthorizeRemoteStop basically works in the same way as eRoamingAuthorizeRemoteStart. The only difference is that this request is sent in order to initiate the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteStart request.
     * @summary Eroamingauthorizeremotestop V21
     * @param {string} [externalID]
     * @param {ERoamingAuthorizeRemoteStop} [eRoamingAuthorizeRemoteStop]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post(
      externalID?: string,
      eRoamingAuthorizeRemoteStop?: ERoamingAuthorizeRemoteStop,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAcknowledgment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post(
          externalID,
          eRoamingAuthorizeRemoteStop,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: EMP Online `OPTIONAL`, EMP Offline `MANDATORY`  ![Get Charge Detail Records diagram](images/getcdr.png)  The operation allows EMPs to download CDRs that have been sent to Hubject by partner CPOs. This means if for example Hubject was unable to forward a CDR from a CPO to an EMP due to technical problems in the EMP’s backend, the EMP will still have the option of obtaining these CDRs. The EMP `MUST` specify a date range in the request. Hubject will return a list of all CDRs received by the HBS within the specified date range for the requesting EMP (i.e. all CDRs within the date range where the corresponding charging process was authorized by the EMP or authorized by Hubject based on the EMP’s authentication data.  Hubject does not check whether a requested CDR has already been provided to the requesting EMP in the past.  Pagination:  Starting from OICP 2.3, eRoaminGetChargeDetailRecords uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of ChargeDetailRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Example:  Using OICP 2.3 GetChargeDetailRecords endpoint for PROD environment:  https://service.hubject.com/api/oicp/cdrmgmt/v22/providers/{providerID}/get-charge-detail-records-request?page=0&amp;size=1500  In the previous request we are telling to provide page __0__ with __1500__ records in it.  Important  The default number of records provided in the response are __20__ elements and the maximum number of records possible to obtain per page are __2000__.
     * @summary Eroaminggetchargedetailrecords V22
     * @param {string} [providerID]
     * @param {ERoamingGetChargeDetailRecords} [eRoamingGetChargeDetailRecords]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post(
      providerID?: string,
      eRoamingGetChargeDetailRecords?: ERoamingGetChargeDetailRecords,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingChargeDetailRecords>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post(
          providerID,
          eRoamingGetChargeDetailRecords,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`  When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of EVSE pricing data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid EVSE pricing data available in the HBS for the requesting EMP are grouped by OperatorID and sent in response to the request.  The operation also allows the use of the LastCall filter. When the LastCall filter is used, only EVSE pricing data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
     * @summary Eroamingpullevsepricing V10
     * @param {string} [providerID]
     * @param {ERoamingPullEVSEPricing} [eRoamingPullEVSEPricing]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingPullEVSEPricingV10Pullevsepricingv10Post(
      providerID?: string,
      eRoamingPullEVSEPricing?: ERoamingPullEVSEPricing,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingEVSEPricing>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingPullEVSEPricingV10Pullevsepricingv10Post(
          providerID,
          eRoamingPullEVSEPricing,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingPullEVSEPricingV10Pullevsepricingv10Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Pull evse data diagram](images/pullevsedata.png)  When an EMP sends an eRoamingPullEVSEData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSEData from Hubject. When an EMP sends an eRoamingPullEVSEData request, Hubject identifies all currently valid EVSEData records of all operators.  For every EVSE data record Hubject identifies the timestamp of the last update, which has been performed on the record. The timestamp is returned with the attribute “lastUpdate”.  __Delta pull:__  As mentioned above, the operation by default returns all currently valid EVSE data records. However, the requesting EMP has the possibility to download only the changes (delta) compared to a certain time in the past. In order to do so, the EMP MUST provide the optional date/time field “LastCall”, indicating his last EVSE pull request. In case that Hubject receives the LastCall parameter, Hubject compares the EVSE records from the time of the last call with the currently valid records. As a result, Hubject assigns the attribute “deltaType” (possible values: insert, update, delete) to every response EVSE data record indicating whether the particular record has been inserted, updated or deleted in the meantime. EVSE data records that have not changed will not be part of the response.  Note: * The delta pull option cannot be combined with radial search, because in some cases this could lead to data inconsistency on the EMP’s side. This is why the API only allows the provision of either the attribute “SearchCenter” or “LastCall”.  __Pagination:__  Starting from OICP 2.3, eRoamingPullEvseData uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of EvseDataRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Important: * __The default number of records provided in the eRoamingEvseData response is 20 elements.__
     * @summary Eroamingpullevsedata V23
     * @param {string} [providerID]
     * @param {ERoamingPullEVSEData} [eRoamingPullEVSEData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingPullEvseDataV23Pullevsedatav23Post(
      providerID?: string,
      eRoamingPullEVSEData?: ERoamingPullEVSEData,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingEVSEData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingPullEvseDataV23Pullevsedatav23Post(
          providerID,
          eRoamingPullEVSEData,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingPullEvseDataV23Pullevsedatav23Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `Mandatory`  ![Pull EVSE status](images/pullevsestatus.png)  When an EMP sends an eRoamingPullEVSEStatus request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSE status data from Hubject. When an EMP sends an eRoamingPullEVSEStatus request, Hubject identifies all currently valid EVSE status records of all operators.  Hubject groups all resulting EVSE status records according to the related CPO. The response structure contains an “EvseStatuses” node that envelopes an “OperatorEVSEStatus” node for every CPO with currently valid and accessible status data records.
     * @summary Eroamingpullevsestatus V21
     * @param {string} [providerID]
     * @param {Body} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingPullEvseStatusV21Pullevsestatusv21Post(
      providerID?: string,
      body?: Body,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingPullEVSEStatusOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingPullEvseStatusV21Pullevsestatusv21Post(
          providerID,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingPullEvseStatusV21Pullevsestatusv21Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`    When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of pricing product data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid pricing products data available in the HBS for the requesting EMP (and pushed by CPOs whose OperatorIDs are supplied in the request) are grouped by OperatorID and sent in response to the request.    The operation also allows the use of the LastCall filter. When the LastCall filter is used, only pricing product data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
     * @summary Eroamingpullpricingproductdata V10
     * @param {string} [providerID]
     * @param {ERoamingPullPricingProductData} [eRoamingPullPricingProductData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post(
      providerID?: string,
      eRoamingPullPricingProductData?: ERoamingPullPricingProductData,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingPricingProductData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post(
          providerID,
          eRoamingPullPricingProductData,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Push authentication data diagram](images/pushauthentificationdata.png)  When an EMP sends an eRoamingPushAuthenticationData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (Hubject must be the subscriber). If so, the operation allows uploading authentication data to Hubject. Furthermore, it is possible to update authentication data that has been pushed with an earlier operation request. How Hubject handles the transferred data `MUST` be defined in the request field “ActionType”, which offers four options (see below).  The authentication data to be inserted or updated `MUST` be provided with the “ProviderAuthenticationData” field, which consists of “AuthenticationDataRecord” structures. Hubject keeps a history of all updated and changed data records. Every successful push operation – irrespective of the performed action – leads to a new version of currently valid data records. Furthermore, each operation is logged with the current timestamp. Thus, Hubject can reconstruct the status of authentication data for every point in time in the past.  __Action types:__  * __fullLoad:__ The EMP uploads the full set of current authentication data. Hubject does not compare the new data to old (earlier pushed) data. It keeps a history of old data records and handles the newly provided data as valid. In order to allow an easy deletion of all records, it is possible to perform a fullLoad with an empty list of records.  * __insert:__ The EMP adds further authentication data records to the current set of data. Hubject verifies that the provided data records do not already exist in the currently valid data status. If so, the transaction will be aborted, no data will be inserted, and the request will be answered with an error message. Error details will be provided with the “AdditionalInfo” field.  * __update:__ The EMP updates data records of the current set of data. Hubject verifies that the provided data records do exist in the currently valid data status. If not, the transaction will be aborted, no data will be updated, and the request will be answered with an error message.  * __delete:__ The EMP deletes data records of the current set of data.  __PIN security:__  The authentication data records that are uploaded to Hubject contain one of the defined identification types. The identification type “QRCodeIdentificationType” contains – besides an “EvcoID” field – a “PIN” field or a “HashedPIN” field (only one of the two options must be provided). For security reasons, Hubject generally does not store PINs in clear text, but always as encrypted hash values. When uploading authentication data to Hubject, the EMPs can directly provide hashed PIN values (using the field “HashedPIN”). In case that the PINs are provided in clear text (field “PIN”), Hubject will generate a hash value for every PIN and will store only the hashes. Hubject by default generates a hash using Bcrypt as a hashing function.  In case that an EMP provides already hashed PINs, he `MUST` also specify the corresponding hash generation algorithm so that Hubject can reproduce the hash generation when processing a request for authorization. For this reason, the “HashedPIN” field contains detailed information concerning the hash function and the hash salt value (for salted hash functions) that must be used for hash generation.  __EVCO consistency:__  EvcoIDs contain the ID of the corresponding EMP. With every data upload operation Hubject checks whether the given EMP’s ProviderID (or Sub-ProviderIDs if necessary) matches every given EvcoID. If not, Hubject refuses the data upload and responds with the status code 019.  Note:  The eRoamingPushAuthenticationData operation `MUST` always be used sequentially.
     * @summary Eroamingpushauthenticationdata V21
     * @param {string} [providerID]
     * @param {ERoamingPushAuthenticationData} [eRoamingPushAuthenticationData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post(
      providerID?: string,
      eRoamingPushAuthenticationData?: ERoamingPushAuthenticationData,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAcknowledgment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post(
          providerID,
          eRoamingPushAuthenticationData,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPClientAPIApi.eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * EMPOICPClientAPIApi - factory interface
 * @export
 */
export const EMPOICPClientAPIApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EMPOICPClientAPIApiFp(configuration);
  return {
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`   * This operation is used by EMPs in order to remotely reserve a charging point.  ![Reservation start diagram](images/reservationstart.png)  __Functional Description:__  Scenario:  A customer of an EMP wants to reserve a charging point of a CPO for a later charging process. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a reservation of the CPO’s charging point by sending an eRoamingAuthorizeRemoteReservationStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID. The demanded reservation product can be specified using the field PartnerProductID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service Reservation (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the reservation process and forwards the request (including the SessionID) to the CPO. The CPO MUST return an eRoamingAcknowledgement message that MUST contain the result indicating whether the reservation was successful and that MAY contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.
     * @summary Eroamingauthorizeremotereservationstart V11
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteReservationStart} [eRoamingAuthorizeRemoteReservationStart]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post(
      providerID?: string,
      eRoamingAuthorizeRemoteReservationStart?: ERoamingAuthorizeRemoteReservationStart,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAcknowledgment> {
      return localVarFp
        .eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post(
          providerID,
          eRoamingAuthorizeRemoteReservationStart,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Reservation stop diagram](images/reservationstop.png)  eRoamingAuthorizeRemoteReservationStop basically works in the same way as eRoamingAuthorizeRemoteReservationStart. The only difference is that this request is sent in order to end the reservation of a charging spot. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteReservationStart request. After the eRoamingAuthorizeRemoteReservationStop the CPO `MUST` provide a CDR.
     * @summary Eroamingauthorizeremotereservationstop V1
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteReservationStop} [eRoamingAuthorizeRemoteReservationStop]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post(
      providerID?: string,
      eRoamingAuthorizeRemoteReservationStop?: ERoamingAuthorizeRemoteReservationStop,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAcknowledgment> {
      return localVarFp
        .eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post(
          providerID,
          eRoamingAuthorizeRemoteReservationStop,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`   * This operation is used by EMPs in order to remotely start a charging process  The service that is offered by Hubject in order to allow customers to directly start a charging process via mobile app.  ![Remote start diagram](images/remotestart.png)   __Functional Description:__  __Scenario:__  A customer of an EMP wants to charge a vehicle at a charging station of a CPO. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a charging process at the CPO’s charging station by sending an eRoamingAuthorizeRemoteStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the following process and forwards the request (including the SessionID) to the CPO. The CPO `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the charging process will be started and that `MAY` contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.  Best Practices:   * Please ensure a request run time of under 10 seconds including network roundtrip.
     * @summary Eroamingauthorizeremotestart V21
     * @param {string} [providerID]
     * @param {ERoamingAuthorizeRemoteStart} [eRoamingAuthorizeRemoteStart]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post(
      providerID?: string,
      eRoamingAuthorizeRemoteStart?: ERoamingAuthorizeRemoteStart,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAcknowledgment> {
      return localVarFp
        .eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post(
          providerID,
          eRoamingAuthorizeRemoteStart,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Remote stop diagram](images/remotestop.png)  eRoamingAuthorizeRemoteStop basically works in the same way as eRoamingAuthorizeRemoteStart. The only difference is that this request is sent in order to initiate the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteStart request.
     * @summary Eroamingauthorizeremotestop V21
     * @param {string} [externalID]
     * @param {ERoamingAuthorizeRemoteStop} [eRoamingAuthorizeRemoteStop]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post(
      externalID?: string,
      eRoamingAuthorizeRemoteStop?: ERoamingAuthorizeRemoteStop,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAcknowledgment> {
      return localVarFp
        .eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post(
          externalID,
          eRoamingAuthorizeRemoteStop,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: EMP Online `OPTIONAL`, EMP Offline `MANDATORY`  ![Get Charge Detail Records diagram](images/getcdr.png)  The operation allows EMPs to download CDRs that have been sent to Hubject by partner CPOs. This means if for example Hubject was unable to forward a CDR from a CPO to an EMP due to technical problems in the EMP’s backend, the EMP will still have the option of obtaining these CDRs. The EMP `MUST` specify a date range in the request. Hubject will return a list of all CDRs received by the HBS within the specified date range for the requesting EMP (i.e. all CDRs within the date range where the corresponding charging process was authorized by the EMP or authorized by Hubject based on the EMP’s authentication data.  Hubject does not check whether a requested CDR has already been provided to the requesting EMP in the past.  Pagination:  Starting from OICP 2.3, eRoaminGetChargeDetailRecords uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of ChargeDetailRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Example:  Using OICP 2.3 GetChargeDetailRecords endpoint for PROD environment:  https://service.hubject.com/api/oicp/cdrmgmt/v22/providers/{providerID}/get-charge-detail-records-request?page=0&amp;size=1500  In the previous request we are telling to provide page __0__ with __1500__ records in it.  Important  The default number of records provided in the response are __20__ elements and the maximum number of records possible to obtain per page are __2000__.
     * @summary Eroaminggetchargedetailrecords V22
     * @param {string} [providerID]
     * @param {ERoamingGetChargeDetailRecords} [eRoamingGetChargeDetailRecords]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post(
      providerID?: string,
      eRoamingGetChargeDetailRecords?: ERoamingGetChargeDetailRecords,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingChargeDetailRecords> {
      return localVarFp
        .eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post(
          providerID,
          eRoamingGetChargeDetailRecords,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`  When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of EVSE pricing data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid EVSE pricing data available in the HBS for the requesting EMP are grouped by OperatorID and sent in response to the request.  The operation also allows the use of the LastCall filter. When the LastCall filter is used, only EVSE pricing data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
     * @summary Eroamingpullevsepricing V10
     * @param {string} [providerID]
     * @param {ERoamingPullEVSEPricing} [eRoamingPullEVSEPricing]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullEVSEPricingV10Pullevsepricingv10Post(
      providerID?: string,
      eRoamingPullEVSEPricing?: ERoamingPullEVSEPricing,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingEVSEPricing> {
      return localVarFp
        .eRoamingPullEVSEPricingV10Pullevsepricingv10Post(
          providerID,
          eRoamingPullEVSEPricing,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Pull evse data diagram](images/pullevsedata.png)  When an EMP sends an eRoamingPullEVSEData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSEData from Hubject. When an EMP sends an eRoamingPullEVSEData request, Hubject identifies all currently valid EVSEData records of all operators.  For every EVSE data record Hubject identifies the timestamp of the last update, which has been performed on the record. The timestamp is returned with the attribute “lastUpdate”.  __Delta pull:__  As mentioned above, the operation by default returns all currently valid EVSE data records. However, the requesting EMP has the possibility to download only the changes (delta) compared to a certain time in the past. In order to do so, the EMP MUST provide the optional date/time field “LastCall”, indicating his last EVSE pull request. In case that Hubject receives the LastCall parameter, Hubject compares the EVSE records from the time of the last call with the currently valid records. As a result, Hubject assigns the attribute “deltaType” (possible values: insert, update, delete) to every response EVSE data record indicating whether the particular record has been inserted, updated or deleted in the meantime. EVSE data records that have not changed will not be part of the response.  Note: * The delta pull option cannot be combined with radial search, because in some cases this could lead to data inconsistency on the EMP’s side. This is why the API only allows the provision of either the attribute “SearchCenter” or “LastCall”.  __Pagination:__  Starting from OICP 2.3, eRoamingPullEvseData uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of EvseDataRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Important: * __The default number of records provided in the eRoamingEvseData response is 20 elements.__
     * @summary Eroamingpullevsedata V23
     * @param {string} [providerID]
     * @param {ERoamingPullEVSEData} [eRoamingPullEVSEData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullEvseDataV23Pullevsedatav23Post(
      providerID?: string,
      eRoamingPullEVSEData?: ERoamingPullEVSEData,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingEVSEData> {
      return localVarFp
        .eRoamingPullEvseDataV23Pullevsedatav23Post(
          providerID,
          eRoamingPullEVSEData,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `Mandatory`  ![Pull EVSE status](images/pullevsestatus.png)  When an EMP sends an eRoamingPullEVSEStatus request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSE status data from Hubject. When an EMP sends an eRoamingPullEVSEStatus request, Hubject identifies all currently valid EVSE status records of all operators.  Hubject groups all resulting EVSE status records according to the related CPO. The response structure contains an “EvseStatuses” node that envelopes an “OperatorEVSEStatus” node for every CPO with currently valid and accessible status data records.
     * @summary Eroamingpullevsestatus V21
     * @param {string} [providerID]
     * @param {Body} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullEvseStatusV21Pullevsestatusv21Post(
      providerID?: string,
      body?: Body,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingPullEVSEStatusOutput> {
      return localVarFp
        .eRoamingPullEvseStatusV21Pullevsestatusv21Post(
          providerID,
          body,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`    When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of pricing product data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid pricing products data available in the HBS for the requesting EMP (and pushed by CPOs whose OperatorIDs are supplied in the request) are grouped by OperatorID and sent in response to the request.    The operation also allows the use of the LastCall filter. When the LastCall filter is used, only pricing product data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
     * @summary Eroamingpullpricingproductdata V10
     * @param {string} [providerID]
     * @param {ERoamingPullPricingProductData} [eRoamingPullPricingProductData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post(
      providerID?: string,
      eRoamingPullPricingProductData?: ERoamingPullPricingProductData,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingPricingProductData> {
      return localVarFp
        .eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post(
          providerID,
          eRoamingPullPricingProductData,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Push authentication data diagram](images/pushauthentificationdata.png)  When an EMP sends an eRoamingPushAuthenticationData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (Hubject must be the subscriber). If so, the operation allows uploading authentication data to Hubject. Furthermore, it is possible to update authentication data that has been pushed with an earlier operation request. How Hubject handles the transferred data `MUST` be defined in the request field “ActionType”, which offers four options (see below).  The authentication data to be inserted or updated `MUST` be provided with the “ProviderAuthenticationData” field, which consists of “AuthenticationDataRecord” structures. Hubject keeps a history of all updated and changed data records. Every successful push operation – irrespective of the performed action – leads to a new version of currently valid data records. Furthermore, each operation is logged with the current timestamp. Thus, Hubject can reconstruct the status of authentication data for every point in time in the past.  __Action types:__  * __fullLoad:__ The EMP uploads the full set of current authentication data. Hubject does not compare the new data to old (earlier pushed) data. It keeps a history of old data records and handles the newly provided data as valid. In order to allow an easy deletion of all records, it is possible to perform a fullLoad with an empty list of records.  * __insert:__ The EMP adds further authentication data records to the current set of data. Hubject verifies that the provided data records do not already exist in the currently valid data status. If so, the transaction will be aborted, no data will be inserted, and the request will be answered with an error message. Error details will be provided with the “AdditionalInfo” field.  * __update:__ The EMP updates data records of the current set of data. Hubject verifies that the provided data records do exist in the currently valid data status. If not, the transaction will be aborted, no data will be updated, and the request will be answered with an error message.  * __delete:__ The EMP deletes data records of the current set of data.  __PIN security:__  The authentication data records that are uploaded to Hubject contain one of the defined identification types. The identification type “QRCodeIdentificationType” contains – besides an “EvcoID” field – a “PIN” field or a “HashedPIN” field (only one of the two options must be provided). For security reasons, Hubject generally does not store PINs in clear text, but always as encrypted hash values. When uploading authentication data to Hubject, the EMPs can directly provide hashed PIN values (using the field “HashedPIN”). In case that the PINs are provided in clear text (field “PIN”), Hubject will generate a hash value for every PIN and will store only the hashes. Hubject by default generates a hash using Bcrypt as a hashing function.  In case that an EMP provides already hashed PINs, he `MUST` also specify the corresponding hash generation algorithm so that Hubject can reproduce the hash generation when processing a request for authorization. For this reason, the “HashedPIN” field contains detailed information concerning the hash function and the hash salt value (for salted hash functions) that must be used for hash generation.  __EVCO consistency:__  EvcoIDs contain the ID of the corresponding EMP. With every data upload operation Hubject checks whether the given EMP’s ProviderID (or Sub-ProviderIDs if necessary) matches every given EvcoID. If not, Hubject refuses the data upload and responds with the status code 019.  Note:  The eRoamingPushAuthenticationData operation `MUST` always be used sequentially.
     * @summary Eroamingpushauthenticationdata V21
     * @param {string} [providerID]
     * @param {ERoamingPushAuthenticationData} [eRoamingPushAuthenticationData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post(
      providerID?: string,
      eRoamingPushAuthenticationData?: ERoamingPushAuthenticationData,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAcknowledgment> {
      return localVarFp
        .eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post(
          providerID,
          eRoamingPushAuthenticationData,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EMPOICPClientAPIApi - object-oriented interface
 * @export
 * @class EMPOICPClientAPIApi
 * @extends {BaseAPI}
 */
export class EMPOICPClientAPIApi extends BaseAPI {
  /**
   * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`   * This operation is used by EMPs in order to remotely reserve a charging point.  ![Reservation start diagram](images/reservationstart.png)  __Functional Description:__  Scenario:  A customer of an EMP wants to reserve a charging point of a CPO for a later charging process. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a reservation of the CPO’s charging point by sending an eRoamingAuthorizeRemoteReservationStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID. The demanded reservation product can be specified using the field PartnerProductID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service Reservation (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the reservation process and forwards the request (including the SessionID) to the CPO. The CPO MUST return an eRoamingAcknowledgement message that MUST contain the result indicating whether the reservation was successful and that MAY contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.
   * @summary Eroamingauthorizeremotereservationstart V11
   * @param {string} [providerID]
   * @param {ERoamingAuthorizeRemoteReservationStart} [eRoamingAuthorizeRemoteReservationStart]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post(
    providerID?: string,
    eRoamingAuthorizeRemoteReservationStart?: ERoamingAuthorizeRemoteReservationStart,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingAuthorizeRemoteReservationStartV11Authorizeremotereservationstartv11Post(
        providerID,
        eRoamingAuthorizeRemoteReservationStart,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Reservation stop diagram](images/reservationstop.png)  eRoamingAuthorizeRemoteReservationStop basically works in the same way as eRoamingAuthorizeRemoteReservationStart. The only difference is that this request is sent in order to end the reservation of a charging spot. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteReservationStart request. After the eRoamingAuthorizeRemoteReservationStop the CPO `MUST` provide a CDR.
   * @summary Eroamingauthorizeremotereservationstop V1
   * @param {string} [providerID]
   * @param {ERoamingAuthorizeRemoteReservationStop} [eRoamingAuthorizeRemoteReservationStop]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post(
    providerID?: string,
    eRoamingAuthorizeRemoteReservationStop?: ERoamingAuthorizeRemoteReservationStop,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingAuthorizeRemoteReservationStopV1Authorizeremotereservationstopv1Post(
        providerID,
        eRoamingAuthorizeRemoteReservationStop,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: `MANDATORY`   * This operation is used by EMPs in order to remotely start a charging process  The service that is offered by Hubject in order to allow customers to directly start a charging process via mobile app.  ![Remote start diagram](images/remotestart.png)   __Functional Description:__  __Scenario:__  A customer of an EMP wants to charge a vehicle at a charging station of a CPO. The customer informs his EMP of his intention, e.g. via mobile phone or smart phone application. The EMP’s provider system can then initiate a charging process at the CPO’s charging station by sending an eRoamingAuthorizeRemoteStart request to Hubject. The request `MUST` contain the ProviderID and the EvseID.  Hubject will derive the CPO’s OperatorID from the EvseID.  Hubject will check whether there is a valid contract between the two partners for the service (EMP must be the subscriber). If so, Hubject continues with checking the charging point compatibility. In case that the CPO has uploaded at least one charging point data record, Hubject will check whether the requested EvseID is among the uploaded data. If not, Hubject will respond with the status code 603 “Unknown EvseID”. If yes, Hubject will check whether the charging spot’s property “IsHubjectCompatible” is set “true”. If the property is false, Hubject will respond with the status code 604 “EvseID is not Hubject compatible”.  In case that the requested EvseID is compatible or the CPO has not uploaded any EVSE records at all, Hubject generates a SessionID for the following process and forwards the request (including the SessionID) to the CPO. The CPO `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the charging process will be started and that `MAY` contain a status code for further information.  In case that the CPO’s system cannot be addressed (e.g. due to technical problems), Hubject will return to the requestor a “false” result and a message indicating the connection error.  Best Practices:   * Please ensure a request run time of under 10 seconds including network roundtrip.
   * @summary Eroamingauthorizeremotestart V21
   * @param {string} [providerID]
   * @param {ERoamingAuthorizeRemoteStart} [eRoamingAuthorizeRemoteStart]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post(
    providerID?: string,
    eRoamingAuthorizeRemoteStart?: ERoamingAuthorizeRemoteStart,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingAuthorizeRemoteStartV21Authorizeremotestartv21Post(
        providerID,
        eRoamingAuthorizeRemoteStart,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Remote stop diagram](images/remotestop.png)  eRoamingAuthorizeRemoteStop basically works in the same way as eRoamingAuthorizeRemoteStart. The only difference is that this request is sent in order to initiate the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeRemoteStart request.
   * @summary Eroamingauthorizeremotestop V21
   * @param {string} [externalID]
   * @param {ERoamingAuthorizeRemoteStop} [eRoamingAuthorizeRemoteStop]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post(
    externalID?: string,
    eRoamingAuthorizeRemoteStop?: ERoamingAuthorizeRemoteStop,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingAuthorizeRemoteStopV21Authorizeremotestopv21Post(
        externalID,
        eRoamingAuthorizeRemoteStop,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: EMP Online `OPTIONAL`, EMP Offline `MANDATORY`  ![Get Charge Detail Records diagram](images/getcdr.png)  The operation allows EMPs to download CDRs that have been sent to Hubject by partner CPOs. This means if for example Hubject was unable to forward a CDR from a CPO to an EMP due to technical problems in the EMP’s backend, the EMP will still have the option of obtaining these CDRs. The EMP `MUST` specify a date range in the request. Hubject will return a list of all CDRs received by the HBS within the specified date range for the requesting EMP (i.e. all CDRs within the date range where the corresponding charging process was authorized by the EMP or authorized by Hubject based on the EMP’s authentication data.  Hubject does not check whether a requested CDR has already been provided to the requesting EMP in the past.  Pagination:  Starting from OICP 2.3, eRoaminGetChargeDetailRecords uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of ChargeDetailRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Example:  Using OICP 2.3 GetChargeDetailRecords endpoint for PROD environment:  https://service.hubject.com/api/oicp/cdrmgmt/v22/providers/{providerID}/get-charge-detail-records-request?page=0&amp;size=1500  In the previous request we are telling to provide page __0__ with __1500__ records in it.  Important  The default number of records provided in the response are __20__ elements and the maximum number of records possible to obtain per page are __2000__.
   * @summary Eroaminggetchargedetailrecords V22
   * @param {string} [providerID]
   * @param {ERoamingGetChargeDetailRecords} [eRoamingGetChargeDetailRecords]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post(
    providerID?: string,
    eRoamingGetChargeDetailRecords?: ERoamingGetChargeDetailRecords,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingGetChargeDetailRecordsV22Getchargedetailrecordsv22Post(
        providerID,
        eRoamingGetChargeDetailRecords,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`  When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of EVSE pricing data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid EVSE pricing data available in the HBS for the requesting EMP are grouped by OperatorID and sent in response to the request.  The operation also allows the use of the LastCall filter. When the LastCall filter is used, only EVSE pricing data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
   * @summary Eroamingpullevsepricing V10
   * @param {string} [providerID]
   * @param {ERoamingPullEVSEPricing} [eRoamingPullEVSEPricing]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingPullEVSEPricingV10Pullevsepricingv10Post(
    providerID?: string,
    eRoamingPullEVSEPricing?: ERoamingPullEVSEPricing,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingPullEVSEPricingV10Pullevsepricingv10Post(
        providerID,
        eRoamingPullEVSEPricing,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Pull evse data diagram](images/pullevsedata.png)  When an EMP sends an eRoamingPullEVSEData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSEData from Hubject. When an EMP sends an eRoamingPullEVSEData request, Hubject identifies all currently valid EVSEData records of all operators.  For every EVSE data record Hubject identifies the timestamp of the last update, which has been performed on the record. The timestamp is returned with the attribute “lastUpdate”.  __Delta pull:__  As mentioned above, the operation by default returns all currently valid EVSE data records. However, the requesting EMP has the possibility to download only the changes (delta) compared to a certain time in the past. In order to do so, the EMP MUST provide the optional date/time field “LastCall”, indicating his last EVSE pull request. In case that Hubject receives the LastCall parameter, Hubject compares the EVSE records from the time of the last call with the currently valid records. As a result, Hubject assigns the attribute “deltaType” (possible values: insert, update, delete) to every response EVSE data record indicating whether the particular record has been inserted, updated or deleted in the meantime. EVSE data records that have not changed will not be part of the response.  Note: * The delta pull option cannot be combined with radial search, because in some cases this could lead to data inconsistency on the EMP’s side. This is why the API only allows the provision of either the attribute “SearchCenter” or “LastCall”.  __Pagination:__  Starting from OICP 2.3, eRoamingPullEvseData uses pagination. This is an implementation that EMPs `MUST` use in order to divide the amount of EvseDataRecords contained in the response of the pull request.  The parameters of the pagination are given at the end of the end point: `…​?page=0&amp;size=20` where `page` indicates the number of the page for the response and `size` the amount of records to be provided in the response.  Important: * __The default number of records provided in the eRoamingEvseData response is 20 elements.__
   * @summary Eroamingpullevsedata V23
   * @param {string} [providerID]
   * @param {ERoamingPullEVSEData} [eRoamingPullEVSEData]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingPullEvseDataV23Pullevsedatav23Post(
    providerID?: string,
    eRoamingPullEVSEData?: ERoamingPullEVSEData,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingPullEvseDataV23Pullevsedatav23Post(
        providerID,
        eRoamingPullEVSEData,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: `Mandatory`  ![Pull EVSE status](images/pullevsestatus.png)  When an EMP sends an eRoamingPullEVSEStatus request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (EMP must be the subscriber). If so, the operation allows downloading EVSE status data from Hubject. When an EMP sends an eRoamingPullEVSEStatus request, Hubject identifies all currently valid EVSE status records of all operators.  Hubject groups all resulting EVSE status records according to the related CPO. The response structure contains an “EvseStatuses” node that envelopes an “OperatorEVSEStatus” node for every CPO with currently valid and accessible status data records.
   * @summary Eroamingpullevsestatus V21
   * @param {string} [providerID]
   * @param {Body} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingPullEvseStatusV21Pullevsestatusv21Post(
    providerID?: string,
    body?: Body,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingPullEvseStatusV21Pullevsestatusv21Post(providerID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: `OPTIONAL`    When an EMP sends an eRoamingPullPricingProductData request, Hubject checks whether there is a valid flexible/dynamic pricing business contract (for the service type Authorization) between the EMP and the CPOs whose OperatorIDs are sent in the request. If so, the operation allows the download of pricing product data pushed to the HBS by these CPOs for the requesting EMP. When this request is received from an EMP, currently valid pricing products data available in the HBS for the requesting EMP (and pushed by CPOs whose OperatorIDs are supplied in the request) are grouped by OperatorID and sent in response to the request.    The operation also allows the use of the LastCall filter. When the LastCall filter is used, only pricing product data changes that have taken place after the date/time value provided in the “LastCall&quot; field of the request are sent to the EMP.
   * @summary Eroamingpullpricingproductdata V10
   * @param {string} [providerID]
   * @param {ERoamingPullPricingProductData} [eRoamingPullPricingProductData]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post(
    providerID?: string,
    eRoamingPullPricingProductData?: ERoamingPullPricingProductData,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingPullPricingProductDataV10Pullpricingproductdatav10Post(
        providerID,
        eRoamingPullPricingProductData,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `SEND`   * Implementation: `MANDATORY`  ![Push authentication data diagram](images/pushauthentificationdata.png)  When an EMP sends an eRoamingPushAuthenticationData request, Hubject checks whether there is a valid contract between Hubject and the EMP for the service type (Hubject must be the subscriber). If so, the operation allows uploading authentication data to Hubject. Furthermore, it is possible to update authentication data that has been pushed with an earlier operation request. How Hubject handles the transferred data `MUST` be defined in the request field “ActionType”, which offers four options (see below).  The authentication data to be inserted or updated `MUST` be provided with the “ProviderAuthenticationData” field, which consists of “AuthenticationDataRecord” structures. Hubject keeps a history of all updated and changed data records. Every successful push operation – irrespective of the performed action – leads to a new version of currently valid data records. Furthermore, each operation is logged with the current timestamp. Thus, Hubject can reconstruct the status of authentication data for every point in time in the past.  __Action types:__  * __fullLoad:__ The EMP uploads the full set of current authentication data. Hubject does not compare the new data to old (earlier pushed) data. It keeps a history of old data records and handles the newly provided data as valid. In order to allow an easy deletion of all records, it is possible to perform a fullLoad with an empty list of records.  * __insert:__ The EMP adds further authentication data records to the current set of data. Hubject verifies that the provided data records do not already exist in the currently valid data status. If so, the transaction will be aborted, no data will be inserted, and the request will be answered with an error message. Error details will be provided with the “AdditionalInfo” field.  * __update:__ The EMP updates data records of the current set of data. Hubject verifies that the provided data records do exist in the currently valid data status. If not, the transaction will be aborted, no data will be updated, and the request will be answered with an error message.  * __delete:__ The EMP deletes data records of the current set of data.  __PIN security:__  The authentication data records that are uploaded to Hubject contain one of the defined identification types. The identification type “QRCodeIdentificationType” contains – besides an “EvcoID” field – a “PIN” field or a “HashedPIN” field (only one of the two options must be provided). For security reasons, Hubject generally does not store PINs in clear text, but always as encrypted hash values. When uploading authentication data to Hubject, the EMPs can directly provide hashed PIN values (using the field “HashedPIN”). In case that the PINs are provided in clear text (field “PIN”), Hubject will generate a hash value for every PIN and will store only the hashes. Hubject by default generates a hash using Bcrypt as a hashing function.  In case that an EMP provides already hashed PINs, he `MUST` also specify the corresponding hash generation algorithm so that Hubject can reproduce the hash generation when processing a request for authorization. For this reason, the “HashedPIN” field contains detailed information concerning the hash function and the hash salt value (for salted hash functions) that must be used for hash generation.  __EVCO consistency:__  EvcoIDs contain the ID of the corresponding EMP. With every data upload operation Hubject checks whether the given EMP’s ProviderID (or Sub-ProviderIDs if necessary) matches every given EvcoID. If not, Hubject refuses the data upload and responds with the status code 019.  Note:  The eRoamingPushAuthenticationData operation `MUST` always be used sequentially.
   * @summary Eroamingpushauthenticationdata V21
   * @param {string} [providerID]
   * @param {ERoamingPushAuthenticationData} [eRoamingPushAuthenticationData]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPClientAPIApi
   */
  public eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post(
    providerID?: string,
    eRoamingPushAuthenticationData?: ERoamingPushAuthenticationData,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPClientAPIApiFp(this.configuration)
      .eRoamingPushAuthenticationDataV21Pushauthenticationdatav21Post(
        providerID,
        eRoamingPushAuthenticationData,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EMPOICPServerAPIApi - axios parameter creator
 * @export
 */
export const EMPOICPServerAPIApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  __Functional Description:__  Scenario:  A customer of an EMP wants to charge a vehicle at a charging point of a CPO. The customer authenticates at the charging point. The CPO’s operator system does not recognize the customer’s authentication data. In order to authorize the charging process, the CPO’s system can send an eRoamingAuthorizeStart request to Hubject. The request MUST contain the OperatorID and the identification data (e.g. UID or EvcoID) and MAY contain the EvseID.  Hubject generates a SessionID for the charging process and persists important session data (SessionID, EvseID, identification data).  Regarding the further service processing, there are three different options:  a. Hubject first tries to authorize the customer offline by checking authentication master data. Authentication data can be uploaded by EMPs using the eRoamingAuthenticationData service. ![Authorize Start offline diagram](images/authorizestart_offline.png)  b. In case offline authorization is not possible, Hubject tries to derive the EMP from the provided identification data. QR Code and Plug&amp;Charge identification data contain the EvcoID. Hubject can derive the EMP’s ProviderID from the EvcoID. Hubject will directly forward eRoamingAuthorizeStart requests to the EMP. The EMP provider system checks the requested authentication data and responds accordingly, either by authorizing or not authorizing the request. The response `MUST` contain the ProviderID and the AuthorizationStatus and `MAY` contain a list of identification data that is authorized to stop the charging process. In case that the EMP provider system cannot be addressed (e.g. due to technical problems), the corresponding provider will be dealt with as if responding “NotAuthorized”. ![Authorize evco diagram](images/authorize_evco.png)  c. In case that Hubject cannot derive the EMP from the identification data (e.g. with RFID identification), Hubject identifies all EMPs that are under contract with the CPO (EMPs must be the service subscriber) and forwards the eRoamingAuthorizeStart request to all these EMPs (broadcast). Hubject consolidates all EMP responses and creates an overall response, authorizing the request in case that one EMP authorized the request.  ![Authorize Start online diagram](images/authorizestart_online.png)  In case that the request for authorization was not successful, Hubject deletes the corresponding SessionID for the charging process.  The response from Hubject to the CPO contains authorization details and in case of successful authorization the created SessionID and the ProviderID of the authorizing provider.
     * @summary Eroamingauthorizestart V21
     * @param {string} operatorID
     * @param {ERoamingAuthorizeStart} eRoamingAuthorizeStart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeStartV21Authorizestartv21Post: async (
      operatorID: string,
      eRoamingAuthorizeStart: ERoamingAuthorizeStart,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists(
        "eRoamingAuthorizeStartV21Authorizestartv21Post",
        "operatorID",
        operatorID
      );
      // verify required parameter 'eRoamingAuthorizeStart' is not null or undefined
      assertParamExists(
        "eRoamingAuthorizeStartV21Authorizestartv21Post",
        "eRoamingAuthorizeStart",
        eRoamingAuthorizeStart
      );
      const localVarPath = `/authorizestartv21`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (operatorID !== undefined) {
        localVarQueryParameter["operatorID"] = operatorID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingAuthorizeStart,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Authorize stop diagram](images/authorizestop.png)  eRoamingAuthorizeStop basically works in a similar way to the operation eRoamingAuthorizeStart. The request is sent in order to authorize the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeStart request. In most cases, Hubject can derive the EMP that authorized the charging process from the SessionID and can directly and offline authorize the request or forward the request for stopping to the EMP. In case the charging session was originally authorized offline by the HBS, the session `MUST` only be stopped with the same medium, which was used for starting the session
     * @summary Eroamingauthorizestop V21
     * @param {string} operatorID
     * @param {ERoamingAuthorizeStop} eRoamingAuthorizeStop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeStopV21Authorizestopv21Post: async (
      operatorID: string,
      eRoamingAuthorizeStop: ERoamingAuthorizeStop,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists(
        "eRoamingAuthorizeStopV21Authorizestopv21Post",
        "operatorID",
        operatorID
      );
      // verify required parameter 'eRoamingAuthorizeStop' is not null or undefined
      assertParamExists(
        "eRoamingAuthorizeStopV21Authorizestopv21Post",
        "eRoamingAuthorizeStop",
        eRoamingAuthorizeStop
      );
      const localVarPath = `/authorizestopv21`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (operatorID !== undefined) {
        localVarQueryParameter["operatorID"] = operatorID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingAuthorizeStop,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  ![Charge Detail Record diagram](images/cdr.png)  __Functional Description:__  Scenario:  A customer of an EMP has charged a vehicle at a charging station of a CPO. The charging process was started with an eRoamingAuthorizeStart or an eRoamingAuthorizeRemoteStart operation. The process may have been stopped with an eRoamingAuthorizeStop or an eRoamingAuthorizeRemoteStop operation. A preceding stop request is not a necessary precondition for the processing of an eRoamingChargeDetailRecord request. The CPO’s provider system `MUST` send an eRoamingChargeDetailRecord (CDR) after the end of the charging process in order to inform the EMP of the charging session data (e.g. meter values and consumed energy) and further charging process details.  Note:  The CPO `MUST` provide the same SessionID that was assigned to the corresponding charging process. Based on this information Hubject will be able to assign the session data to the correct process.  Hubject will identify the receiving EMP and will forward the CDR to the corresponding EMP. The EMP `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the session data was received successfully and that `MAY` contain a status code for further information.  Hubject will accept only one CDR per SessionID.  In addition to forwarding the CDR to the EMP, Hubject also stores the CDR. In case that the recipient provider’s system cannot be addressed (e.g. due to technical problems), Hubject will nevertheless return to the requestor a positive result provided that storing the CDR was successful.
     * @summary Eroamingchargedetailrecord V22
     * @param {string} operatorID
     * @param {ERoamingChargeDetailRecordInput} eRoamingChargeDetailRecordInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingChargeDetailRecordV22Chargedetailrecordv22Post: async (
      operatorID: string,
      eRoamingChargeDetailRecordInput: ERoamingChargeDetailRecordInput,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists(
        "eRoamingChargeDetailRecordV22Chargedetailrecordv22Post",
        "operatorID",
        operatorID
      );
      // verify required parameter 'eRoamingChargeDetailRecordInput' is not null or undefined
      assertParamExists(
        "eRoamingChargeDetailRecordV22Chargedetailrecordv22Post",
        "eRoamingChargeDetailRecordInput",
        eRoamingChargeDetailRecordInput
      );
      const localVarPath = `/chargedetailrecordv22`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (operatorID !== undefined) {
        localVarQueryParameter["operatorID"] = operatorID;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eRoamingChargeDetailRecordInput,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ![Charging notifications diagram](images/chargingnotifications.png) The ChargingNotification feature enables CPOs to notify EMPs about the end of charge  The ChargingNotification feature basically increases the transparency between CPO - EMP - End Consumer to the level of each charging session.  This feature enables CPO to send various notifications during a single Charging Session. These notifications give the details like  1. When the charging session has started. The CPO can send ChargingNotification of type “Start” to Hubject containing information like ChargingStart, MeterStartValue, EVSEID etc.  2. Consumed Energy values during the charging process or duration of successful charging process that has lapsed. The CPO can send ChargingNotification of type “Progress” to Hubject containing information like ChargingStart, EventOccurred, ChargingDuration, ConsumedEnergyProgress, EVSEID etc. The frequency between two progress notifications for one charging session should be at least 5 minutes.  3. When the charging session has ended (because no energy is transmitted anymore). The CPO can send a ChargingNotification of type “End” to Hubject containing information such as ChargingEnd, ConsumedEnergy, EVSEID etc.  4. Error occurred before charging starts or during charging process or abrupt changing end. The CPO can send a ChargingNotification of type “Error” to Hubject containing information such as ErrorClass, ErrorAdditionalInfo, EVSEID etc.  Hubject will forward Start, Progress, End and Error notification requests to the EMP. The EMP responds with an eRoamingAcknowledgement. This acknowledgement is then being forwarded to the CPO.  This feature should cover all the notifications that could happen between Session Start and Session End in future. Each bit of information increases transparency to the customer of EMP.
     * @summary Eroamingchargingnotifications V11
     * @param {Body1} [body1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingChargingNotificationsV11Chargingnotificationsv11Post: async (
      body1?: Body1,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/chargingnotificationsv11`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body1,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EMPOICPServerAPIApi - functional programming interface
 * @export
 */
export const EMPOICPServerAPIApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EMPOICPServerAPIApiAxiosParamCreator(configuration);
  return {
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  __Functional Description:__  Scenario:  A customer of an EMP wants to charge a vehicle at a charging point of a CPO. The customer authenticates at the charging point. The CPO’s operator system does not recognize the customer’s authentication data. In order to authorize the charging process, the CPO’s system can send an eRoamingAuthorizeStart request to Hubject. The request MUST contain the OperatorID and the identification data (e.g. UID or EvcoID) and MAY contain the EvseID.  Hubject generates a SessionID for the charging process and persists important session data (SessionID, EvseID, identification data).  Regarding the further service processing, there are three different options:  a. Hubject first tries to authorize the customer offline by checking authentication master data. Authentication data can be uploaded by EMPs using the eRoamingAuthenticationData service. ![Authorize Start offline diagram](images/authorizestart_offline.png)  b. In case offline authorization is not possible, Hubject tries to derive the EMP from the provided identification data. QR Code and Plug&amp;Charge identification data contain the EvcoID. Hubject can derive the EMP’s ProviderID from the EvcoID. Hubject will directly forward eRoamingAuthorizeStart requests to the EMP. The EMP provider system checks the requested authentication data and responds accordingly, either by authorizing or not authorizing the request. The response `MUST` contain the ProviderID and the AuthorizationStatus and `MAY` contain a list of identification data that is authorized to stop the charging process. In case that the EMP provider system cannot be addressed (e.g. due to technical problems), the corresponding provider will be dealt with as if responding “NotAuthorized”. ![Authorize evco diagram](images/authorize_evco.png)  c. In case that Hubject cannot derive the EMP from the identification data (e.g. with RFID identification), Hubject identifies all EMPs that are under contract with the CPO (EMPs must be the service subscriber) and forwards the eRoamingAuthorizeStart request to all these EMPs (broadcast). Hubject consolidates all EMP responses and creates an overall response, authorizing the request in case that one EMP authorized the request.  ![Authorize Start online diagram](images/authorizestart_online.png)  In case that the request for authorization was not successful, Hubject deletes the corresponding SessionID for the charging process.  The response from Hubject to the CPO contains authorization details and in case of successful authorization the created SessionID and the ProviderID of the authorizing provider.
     * @summary Eroamingauthorizestart V21
     * @param {string} operatorID
     * @param {ERoamingAuthorizeStart} eRoamingAuthorizeStart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingAuthorizeStartV21Authorizestartv21Post(
      operatorID: string,
      eRoamingAuthorizeStart: ERoamingAuthorizeStart,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAuthorizationStart>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingAuthorizeStartV21Authorizestartv21Post(
          operatorID,
          eRoamingAuthorizeStart,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPServerAPIApi.eRoamingAuthorizeStartV21Authorizestartv21Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Authorize stop diagram](images/authorizestop.png)  eRoamingAuthorizeStop basically works in a similar way to the operation eRoamingAuthorizeStart. The request is sent in order to authorize the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeStart request. In most cases, Hubject can derive the EMP that authorized the charging process from the SessionID and can directly and offline authorize the request or forward the request for stopping to the EMP. In case the charging session was originally authorized offline by the HBS, the session `MUST` only be stopped with the same medium, which was used for starting the session
     * @summary Eroamingauthorizestop V21
     * @param {string} operatorID
     * @param {ERoamingAuthorizeStop} eRoamingAuthorizeStop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingAuthorizeStopV21Authorizestopv21Post(
      operatorID: string,
      eRoamingAuthorizeStop: ERoamingAuthorizeStop,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAuthorizationStop>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingAuthorizeStopV21Authorizestopv21Post(
          operatorID,
          eRoamingAuthorizeStop,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPServerAPIApi.eRoamingAuthorizeStopV21Authorizestopv21Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  ![Charge Detail Record diagram](images/cdr.png)  __Functional Description:__  Scenario:  A customer of an EMP has charged a vehicle at a charging station of a CPO. The charging process was started with an eRoamingAuthorizeStart or an eRoamingAuthorizeRemoteStart operation. The process may have been stopped with an eRoamingAuthorizeStop or an eRoamingAuthorizeRemoteStop operation. A preceding stop request is not a necessary precondition for the processing of an eRoamingChargeDetailRecord request. The CPO’s provider system `MUST` send an eRoamingChargeDetailRecord (CDR) after the end of the charging process in order to inform the EMP of the charging session data (e.g. meter values and consumed energy) and further charging process details.  Note:  The CPO `MUST` provide the same SessionID that was assigned to the corresponding charging process. Based on this information Hubject will be able to assign the session data to the correct process.  Hubject will identify the receiving EMP and will forward the CDR to the corresponding EMP. The EMP `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the session data was received successfully and that `MAY` contain a status code for further information.  Hubject will accept only one CDR per SessionID.  In addition to forwarding the CDR to the EMP, Hubject also stores the CDR. In case that the recipient provider’s system cannot be addressed (e.g. due to technical problems), Hubject will nevertheless return to the requestor a positive result provided that storing the CDR was successful.
     * @summary Eroamingchargedetailrecord V22
     * @param {string} operatorID
     * @param {ERoamingChargeDetailRecordInput} eRoamingChargeDetailRecordInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingChargeDetailRecordV22Chargedetailrecordv22Post(
      operatorID: string,
      eRoamingChargeDetailRecordInput: ERoamingChargeDetailRecordInput,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAcknowledgment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingChargeDetailRecordV22Chargedetailrecordv22Post(
          operatorID,
          eRoamingChargeDetailRecordInput,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPServerAPIApi.eRoamingChargeDetailRecordV22Chargedetailrecordv22Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * ![Charging notifications diagram](images/chargingnotifications.png) The ChargingNotification feature enables CPOs to notify EMPs about the end of charge  The ChargingNotification feature basically increases the transparency between CPO - EMP - End Consumer to the level of each charging session.  This feature enables CPO to send various notifications during a single Charging Session. These notifications give the details like  1. When the charging session has started. The CPO can send ChargingNotification of type “Start” to Hubject containing information like ChargingStart, MeterStartValue, EVSEID etc.  2. Consumed Energy values during the charging process or duration of successful charging process that has lapsed. The CPO can send ChargingNotification of type “Progress” to Hubject containing information like ChargingStart, EventOccurred, ChargingDuration, ConsumedEnergyProgress, EVSEID etc. The frequency between two progress notifications for one charging session should be at least 5 minutes.  3. When the charging session has ended (because no energy is transmitted anymore). The CPO can send a ChargingNotification of type “End” to Hubject containing information such as ChargingEnd, ConsumedEnergy, EVSEID etc.  4. Error occurred before charging starts or during charging process or abrupt changing end. The CPO can send a ChargingNotification of type “Error” to Hubject containing information such as ErrorClass, ErrorAdditionalInfo, EVSEID etc.  Hubject will forward Start, Progress, End and Error notification requests to the EMP. The EMP responds with an eRoamingAcknowledgement. This acknowledgement is then being forwarded to the CPO.  This feature should cover all the notifications that could happen between Session Start and Session End in future. Each bit of information increases transparency to the customer of EMP.
     * @summary Eroamingchargingnotifications V11
     * @param {Body1} [body1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eRoamingChargingNotificationsV11Chargingnotificationsv11Post(
      body1?: Body1,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ERoamingAcknowledgment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.eRoamingChargingNotificationsV11Chargingnotificationsv11Post(
          body1,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "EMPOICPServerAPIApi.eRoamingChargingNotificationsV11Chargingnotificationsv11Post"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * EMPOICPServerAPIApi - factory interface
 * @export
 */
export const EMPOICPServerAPIApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EMPOICPServerAPIApiFp(configuration);
  return {
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  __Functional Description:__  Scenario:  A customer of an EMP wants to charge a vehicle at a charging point of a CPO. The customer authenticates at the charging point. The CPO’s operator system does not recognize the customer’s authentication data. In order to authorize the charging process, the CPO’s system can send an eRoamingAuthorizeStart request to Hubject. The request MUST contain the OperatorID and the identification data (e.g. UID or EvcoID) and MAY contain the EvseID.  Hubject generates a SessionID for the charging process and persists important session data (SessionID, EvseID, identification data).  Regarding the further service processing, there are three different options:  a. Hubject first tries to authorize the customer offline by checking authentication master data. Authentication data can be uploaded by EMPs using the eRoamingAuthenticationData service. ![Authorize Start offline diagram](images/authorizestart_offline.png)  b. In case offline authorization is not possible, Hubject tries to derive the EMP from the provided identification data. QR Code and Plug&amp;Charge identification data contain the EvcoID. Hubject can derive the EMP’s ProviderID from the EvcoID. Hubject will directly forward eRoamingAuthorizeStart requests to the EMP. The EMP provider system checks the requested authentication data and responds accordingly, either by authorizing or not authorizing the request. The response `MUST` contain the ProviderID and the AuthorizationStatus and `MAY` contain a list of identification data that is authorized to stop the charging process. In case that the EMP provider system cannot be addressed (e.g. due to technical problems), the corresponding provider will be dealt with as if responding “NotAuthorized”. ![Authorize evco diagram](images/authorize_evco.png)  c. In case that Hubject cannot derive the EMP from the identification data (e.g. with RFID identification), Hubject identifies all EMPs that are under contract with the CPO (EMPs must be the service subscriber) and forwards the eRoamingAuthorizeStart request to all these EMPs (broadcast). Hubject consolidates all EMP responses and creates an overall response, authorizing the request in case that one EMP authorized the request.  ![Authorize Start online diagram](images/authorizestart_online.png)  In case that the request for authorization was not successful, Hubject deletes the corresponding SessionID for the charging process.  The response from Hubject to the CPO contains authorization details and in case of successful authorization the created SessionID and the ProviderID of the authorizing provider.
     * @summary Eroamingauthorizestart V21
     * @param {string} operatorID
     * @param {ERoamingAuthorizeStart} eRoamingAuthorizeStart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeStartV21Authorizestartv21Post(
      operatorID: string,
      eRoamingAuthorizeStart: ERoamingAuthorizeStart,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAuthorizationStart> {
      return localVarFp
        .eRoamingAuthorizeStartV21Authorizestartv21Post(
          operatorID,
          eRoamingAuthorizeStart,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Authorize stop diagram](images/authorizestop.png)  eRoamingAuthorizeStop basically works in a similar way to the operation eRoamingAuthorizeStart. The request is sent in order to authorize the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeStart request. In most cases, Hubject can derive the EMP that authorized the charging process from the SessionID and can directly and offline authorize the request or forward the request for stopping to the EMP. In case the charging session was originally authorized offline by the HBS, the session `MUST` only be stopped with the same medium, which was used for starting the session
     * @summary Eroamingauthorizestop V21
     * @param {string} operatorID
     * @param {ERoamingAuthorizeStop} eRoamingAuthorizeStop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingAuthorizeStopV21Authorizestopv21Post(
      operatorID: string,
      eRoamingAuthorizeStop: ERoamingAuthorizeStop,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAuthorizationStop> {
      return localVarFp
        .eRoamingAuthorizeStopV21Authorizestopv21Post(
          operatorID,
          eRoamingAuthorizeStop,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  ![Charge Detail Record diagram](images/cdr.png)  __Functional Description:__  Scenario:  A customer of an EMP has charged a vehicle at a charging station of a CPO. The charging process was started with an eRoamingAuthorizeStart or an eRoamingAuthorizeRemoteStart operation. The process may have been stopped with an eRoamingAuthorizeStop or an eRoamingAuthorizeRemoteStop operation. A preceding stop request is not a necessary precondition for the processing of an eRoamingChargeDetailRecord request. The CPO’s provider system `MUST` send an eRoamingChargeDetailRecord (CDR) after the end of the charging process in order to inform the EMP of the charging session data (e.g. meter values and consumed energy) and further charging process details.  Note:  The CPO `MUST` provide the same SessionID that was assigned to the corresponding charging process. Based on this information Hubject will be able to assign the session data to the correct process.  Hubject will identify the receiving EMP and will forward the CDR to the corresponding EMP. The EMP `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the session data was received successfully and that `MAY` contain a status code for further information.  Hubject will accept only one CDR per SessionID.  In addition to forwarding the CDR to the EMP, Hubject also stores the CDR. In case that the recipient provider’s system cannot be addressed (e.g. due to technical problems), Hubject will nevertheless return to the requestor a positive result provided that storing the CDR was successful.
     * @summary Eroamingchargedetailrecord V22
     * @param {string} operatorID
     * @param {ERoamingChargeDetailRecordInput} eRoamingChargeDetailRecordInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingChargeDetailRecordV22Chargedetailrecordv22Post(
      operatorID: string,
      eRoamingChargeDetailRecordInput: ERoamingChargeDetailRecordInput,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAcknowledgment> {
      return localVarFp
        .eRoamingChargeDetailRecordV22Chargedetailrecordv22Post(
          operatorID,
          eRoamingChargeDetailRecordInput,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * ![Charging notifications diagram](images/chargingnotifications.png) The ChargingNotification feature enables CPOs to notify EMPs about the end of charge  The ChargingNotification feature basically increases the transparency between CPO - EMP - End Consumer to the level of each charging session.  This feature enables CPO to send various notifications during a single Charging Session. These notifications give the details like  1. When the charging session has started. The CPO can send ChargingNotification of type “Start” to Hubject containing information like ChargingStart, MeterStartValue, EVSEID etc.  2. Consumed Energy values during the charging process or duration of successful charging process that has lapsed. The CPO can send ChargingNotification of type “Progress” to Hubject containing information like ChargingStart, EventOccurred, ChargingDuration, ConsumedEnergyProgress, EVSEID etc. The frequency between two progress notifications for one charging session should be at least 5 minutes.  3. When the charging session has ended (because no energy is transmitted anymore). The CPO can send a ChargingNotification of type “End” to Hubject containing information such as ChargingEnd, ConsumedEnergy, EVSEID etc.  4. Error occurred before charging starts or during charging process or abrupt changing end. The CPO can send a ChargingNotification of type “Error” to Hubject containing information such as ErrorClass, ErrorAdditionalInfo, EVSEID etc.  Hubject will forward Start, Progress, End and Error notification requests to the EMP. The EMP responds with an eRoamingAcknowledgement. This acknowledgement is then being forwarded to the CPO.  This feature should cover all the notifications that could happen between Session Start and Session End in future. Each bit of information increases transparency to the customer of EMP.
     * @summary Eroamingchargingnotifications V11
     * @param {Body1} [body1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eRoamingChargingNotificationsV11Chargingnotificationsv11Post(
      body1?: Body1,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ERoamingAcknowledgment> {
      return localVarFp
        .eRoamingChargingNotificationsV11Chargingnotificationsv11Post(
          body1,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EMPOICPServerAPIApi - object-oriented interface
 * @export
 * @class EMPOICPServerAPIApi
 * @extends {BaseAPI}
 */
export class EMPOICPServerAPIApi extends BaseAPI {
  /**
   * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  __Functional Description:__  Scenario:  A customer of an EMP wants to charge a vehicle at a charging point of a CPO. The customer authenticates at the charging point. The CPO’s operator system does not recognize the customer’s authentication data. In order to authorize the charging process, the CPO’s system can send an eRoamingAuthorizeStart request to Hubject. The request MUST contain the OperatorID and the identification data (e.g. UID or EvcoID) and MAY contain the EvseID.  Hubject generates a SessionID for the charging process and persists important session data (SessionID, EvseID, identification data).  Regarding the further service processing, there are three different options:  a. Hubject first tries to authorize the customer offline by checking authentication master data. Authentication data can be uploaded by EMPs using the eRoamingAuthenticationData service. ![Authorize Start offline diagram](images/authorizestart_offline.png)  b. In case offline authorization is not possible, Hubject tries to derive the EMP from the provided identification data. QR Code and Plug&amp;Charge identification data contain the EvcoID. Hubject can derive the EMP’s ProviderID from the EvcoID. Hubject will directly forward eRoamingAuthorizeStart requests to the EMP. The EMP provider system checks the requested authentication data and responds accordingly, either by authorizing or not authorizing the request. The response `MUST` contain the ProviderID and the AuthorizationStatus and `MAY` contain a list of identification data that is authorized to stop the charging process. In case that the EMP provider system cannot be addressed (e.g. due to technical problems), the corresponding provider will be dealt with as if responding “NotAuthorized”. ![Authorize evco diagram](images/authorize_evco.png)  c. In case that Hubject cannot derive the EMP from the identification data (e.g. with RFID identification), Hubject identifies all EMPs that are under contract with the CPO (EMPs must be the service subscriber) and forwards the eRoamingAuthorizeStart request to all these EMPs (broadcast). Hubject consolidates all EMP responses and creates an overall response, authorizing the request in case that one EMP authorized the request.  ![Authorize Start online diagram](images/authorizestart_online.png)  In case that the request for authorization was not successful, Hubject deletes the corresponding SessionID for the charging process.  The response from Hubject to the CPO contains authorization details and in case of successful authorization the created SessionID and the ProviderID of the authorizing provider.
   * @summary Eroamingauthorizestart V21
   * @param {string} operatorID
   * @param {ERoamingAuthorizeStart} eRoamingAuthorizeStart
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPServerAPIApi
   */
  public eRoamingAuthorizeStartV21Authorizestartv21Post(
    operatorID: string,
    eRoamingAuthorizeStart: ERoamingAuthorizeStart,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPServerAPIApiFp(this.configuration)
      .eRoamingAuthorizeStartV21Authorizestartv21Post(
        operatorID,
        eRoamingAuthorizeStart,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `RECEIVE`   * Implementation: `OPTIONAL`  ![Authorize stop diagram](images/authorizestop.png)  eRoamingAuthorizeStop basically works in a similar way to the operation eRoamingAuthorizeStart. The request is sent in order to authorize the stopping of a charging process. The request `MUST` contain the SessionID that was created by Hubject after the initial eRoamingAuthorizeStart request. In most cases, Hubject can derive the EMP that authorized the charging process from the SessionID and can directly and offline authorize the request or forward the request for stopping to the EMP. In case the charging session was originally authorized offline by the HBS, the session `MUST` only be stopped with the same medium, which was used for starting the session
   * @summary Eroamingauthorizestop V21
   * @param {string} operatorID
   * @param {ERoamingAuthorizeStop} eRoamingAuthorizeStop
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPServerAPIApi
   */
  public eRoamingAuthorizeStopV21Authorizestopv21Post(
    operatorID: string,
    eRoamingAuthorizeStop: ERoamingAuthorizeStop,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPServerAPIApiFp(this.configuration)
      .eRoamingAuthorizeStopV21Authorizestopv21Post(
        operatorID,
        eRoamingAuthorizeStop,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * __Note:__   * To `RECEIVE`   * Implementation: `MANDATORY`  ![Charge Detail Record diagram](images/cdr.png)  __Functional Description:__  Scenario:  A customer of an EMP has charged a vehicle at a charging station of a CPO. The charging process was started with an eRoamingAuthorizeStart or an eRoamingAuthorizeRemoteStart operation. The process may have been stopped with an eRoamingAuthorizeStop or an eRoamingAuthorizeRemoteStop operation. A preceding stop request is not a necessary precondition for the processing of an eRoamingChargeDetailRecord request. The CPO’s provider system `MUST` send an eRoamingChargeDetailRecord (CDR) after the end of the charging process in order to inform the EMP of the charging session data (e.g. meter values and consumed energy) and further charging process details.  Note:  The CPO `MUST` provide the same SessionID that was assigned to the corresponding charging process. Based on this information Hubject will be able to assign the session data to the correct process.  Hubject will identify the receiving EMP and will forward the CDR to the corresponding EMP. The EMP `MUST` return an eRoamingAcknowledgement message that `MUST` contain the result indicating whether the session data was received successfully and that `MAY` contain a status code for further information.  Hubject will accept only one CDR per SessionID.  In addition to forwarding the CDR to the EMP, Hubject also stores the CDR. In case that the recipient provider’s system cannot be addressed (e.g. due to technical problems), Hubject will nevertheless return to the requestor a positive result provided that storing the CDR was successful.
   * @summary Eroamingchargedetailrecord V22
   * @param {string} operatorID
   * @param {ERoamingChargeDetailRecordInput} eRoamingChargeDetailRecordInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPServerAPIApi
   */
  public eRoamingChargeDetailRecordV22Chargedetailrecordv22Post(
    operatorID: string,
    eRoamingChargeDetailRecordInput: ERoamingChargeDetailRecordInput,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPServerAPIApiFp(this.configuration)
      .eRoamingChargeDetailRecordV22Chargedetailrecordv22Post(
        operatorID,
        eRoamingChargeDetailRecordInput,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ![Charging notifications diagram](images/chargingnotifications.png) The ChargingNotification feature enables CPOs to notify EMPs about the end of charge  The ChargingNotification feature basically increases the transparency between CPO - EMP - End Consumer to the level of each charging session.  This feature enables CPO to send various notifications during a single Charging Session. These notifications give the details like  1. When the charging session has started. The CPO can send ChargingNotification of type “Start” to Hubject containing information like ChargingStart, MeterStartValue, EVSEID etc.  2. Consumed Energy values during the charging process or duration of successful charging process that has lapsed. The CPO can send ChargingNotification of type “Progress” to Hubject containing information like ChargingStart, EventOccurred, ChargingDuration, ConsumedEnergyProgress, EVSEID etc. The frequency between two progress notifications for one charging session should be at least 5 minutes.  3. When the charging session has ended (because no energy is transmitted anymore). The CPO can send a ChargingNotification of type “End” to Hubject containing information such as ChargingEnd, ConsumedEnergy, EVSEID etc.  4. Error occurred before charging starts or during charging process or abrupt changing end. The CPO can send a ChargingNotification of type “Error” to Hubject containing information such as ErrorClass, ErrorAdditionalInfo, EVSEID etc.  Hubject will forward Start, Progress, End and Error notification requests to the EMP. The EMP responds with an eRoamingAcknowledgement. This acknowledgement is then being forwarded to the CPO.  This feature should cover all the notifications that could happen between Session Start and Session End in future. Each bit of information increases transparency to the customer of EMP.
   * @summary Eroamingchargingnotifications V11
   * @param {Body1} [body1]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMPOICPServerAPIApi
   */
  public eRoamingChargingNotificationsV11Chargingnotificationsv11Post(
    body1?: Body1,
    options?: RawAxiosRequestConfig
  ) {
    return EMPOICPServerAPIApiFp(this.configuration)
      .eRoamingChargingNotificationsV11Chargingnotificationsv11Post(
        body1,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
